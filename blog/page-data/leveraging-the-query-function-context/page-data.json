{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/leveraging-the-query-function-context",
    "result": {"data":{"post":{"slug":"/leveraging-the-query-function-context","title":"Leveraging the Query Function Context","date":"26.10.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"Use what React Query provides for optimal type safety","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Leveraging the Query Function Context\",\n  \"description\": \"Use what React Query provides for optimal type safety\",\n  \"date\": \"2021-10-26T00:00:00.000Z\",\n  \"banner\": \"./context.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMFAgT/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABmdstqpNB/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAECEQME/9oACAEBAAEFAubTPTyiFpIy83//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAbEAABBAMAAAAAAAAAAAAAAAAAAQIRMRASgf/aAAgBAQAGPwITR0yVjhR//8QAGxABAAEFAQAAAAAAAAAAAAAAAQARITFBUaH/2gAIAQEAAT8hQ0V8iT1iJHBitKwzozQot2f/2gAMAwEAAgADAAAAEKMP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAEDAQE/EJMb/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAAICAwEAAAAAAAAAAAAAAQARQVEhMZFh/9oACAEBAAE/EDoloHijDyoeZW6veIwDaUzKqH1lFdr9J1ETjL2dz//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"context\",\n    \"title\": \"context\",\n    \"src\": \"/blog/static/f77f007a5cfde787408ed16d3fbab168/bbe0c/context.jpg\",\n    \"srcSet\": [\"/blog/static/f77f007a5cfde787408ed16d3fbab168/46946/context.jpg 240w\", \"/blog/static/f77f007a5cfde787408ed16d3fbab168/55489/context.jpg 480w\", \"/blog/static/f77f007a5cfde787408ed16d3fbab168/bbe0c/context.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"mohammad takhsh\",\n    url: \"https://unsplash.com/@mohammadtkh\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, \"We all strive to improve as engineers, and as time goes by, we hopefully succeed in that endeavour. Maybe we learn new things that invalidate or challenge our previous thinking. Or we realise that patterns that we thought ideal would not scale to the level we now need them to.\"), mdx(\"p\", null, \"Quite some time has passed since I first started to use React Query. I think I learned a great deal on that journey, and I've also \\\"seen\\\" a lot. I want my blog to be as up-to-date as possible, so that you can come back here and re-read it, knowing that the concepts are still valid. This is now more relevant than ever since \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tannerlinsley\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Tanner Linsley\"), \" agreed to link to my blog from the official \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/community/tkdodos-blog\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"React Query documentation\"), \".\"), mdx(\"p\", null, \"That's why I've decided to write this addendum to my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"Effective React Query Keys\"), \" article. Please make sure to read it first to have an understanding of what we are talking about.\"), mdx(\"h2\", {\n    \"id\": \"hot-take\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Hot take\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#hot-take\",\n    \"aria-label\": \"hot take permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(SpacingBox, {\n    mdxType: \"SpacingBox\"\n  }), mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"Don't use inline functions - leverage the Query Function Context given to you, and use a Query Key factory that produces object keys\"), mdx(\"p\", null, \"Inline functions are by far the easiest way to pass parameters to your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \", because they let you closure over other variables available in your custom hook. Let's look at the evergreen todo example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=inline-query-fn\"\n  }, \"type State = 'all' | 'open' | 'done'\\ntype Todo = {\\n  id: number\\n  state: TodoState\\n}\\ntype Todos = ReadonlyArray<Todo>\\n\\nconst fetchTodos = async (state: State): Promise<Todos> => {\\n  const response = await axios.get(`todos/${state}`)\\n  return response.data\\n}\\n\\nexport const useTodos = () => {\\n  // imagine this grabs the current user selection\\n  // from somewhere, e.g. the url\\n  const { state } = useTodoParams()\\n\\n  // \\u2705 The queryFn is an inline function that\\n  // closures over the passed state\\n  return useQuery(['todos', state], () => fetchTodos(state))\\n}\\n\")), mdx(\"p\", null, \"Maybe you recognize the example - It's a slight variation of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"practical-react-query#treat-the-query-key-like-a-dependency-array\"\n  }, \"#1: Practical React Query - Treat the query key like a dependency array\"), \". This works great for simple examples, but it has a quite substantial problem when having lots of parameters. In bigger apps, it's not unheard of to have lots of filter and sorting options, and I've personally seen up to 10 params being passed.\"), mdx(\"p\", null, \"Suppose we want to add sorting to our query. I like to approach these things from the bottom up - starting with the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \" and letting the compiler tell me what I need to change next:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=sorting-todos\",\n    \"metastring\": \"{1,4,6}\",\n    \"{1,4,6}\": true\n  }, \"type Sorting = 'dateCreated' | 'name'\\nconst fetchTodos = async (\\n  state: State,\\n  sorting: Sorting\\n): Promise<Todos> => {\\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\\n  return response.data\\n}\\n\")), mdx(\"p\", null, \"This will certainly yield an error in our custom hook, where we call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fetchTodos\"), \", so let's fix that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=useTodos-with-sorting\",\n    \"metastring\": \"{2,5}\",\n    \"{2,5}\": true\n  }, \"export const useTodos = () => {\\n  const { state, sorting } = useTodoParams()\\n\\n  // \\uD83D\\uDEA8 can you spot the mistake \\u2B07\\uFE0F\\n  return useQuery(['todos', state], () => fetchTodos(state, sorting))\\n}\\n\")), mdx(\"p\", null, \"Maybe you've already spotted the issue: Our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \" got out of sync with our actual dependencies, and no red squiggly lines are screaming at us about it \\uD83D\\uDE14. In the above case, you'll likely spot the issue very fast (hopefully via an integration test), because changing the sorting does not automatically trigger a refetch. And, let's be honest, it's also pretty obvious in this simple example. I have however seen the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \" diverge from the actual dependencies a couple of times in the last months, and with greater complexity, those can result in some hard to track issues. There's also a reason why React comes with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/hooks-rules.html#eslint-plugin\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"react-hooks/exhaustive-deps eslint rule\"), \" to avoid that.\"), mdx(\"p\", null, \"So will React Query now come with its own eslint-rule \\uD83D\\uDC40 ?\"), mdx(\"p\", null, \"Well, that would be one option. There is also the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/dominictwlee/babel-plugin-react-query-key-gen\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"babel-plugin-react-query-key-gen\\n\"), \" that solves this problem by generating query keys for you, including all your dependencies. React Query however comes with a different, built-in way of handling dependencies: The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryFunctionContext\"), \".\"), mdx(\"h2\", {\n    \"id\": \"queryfunctioncontext\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"QueryFunctionContext\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#queryfunctioncontext\",\n    \"aria-label\": \"queryfunctioncontext permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryFunctionContext\"), \" is an object that is passed as argument to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \". You've probably used it before when working with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"infinite queries\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=useInfiniteQuery\"\n  }, \"// this is the QueryFunctionContext \\u2B07\\uFE0F\\nconst fetchProjects = ({ pageParam = 0 }) =>\\n  fetch('/api/projects?cursor=' + pageParam)\\n\\nuseInfiniteQuery('projects', fetchProjects, {\\n  getNextPageParam: (lastPage) => lastPage.nextCursor,\\n})\\n\")), mdx(\"p\", null, \"React Query uses that object to inject information about the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"query\"), \" to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \". In case of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"infinite queries\"), \", you'll get the return value of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"getNextPageParam\"), \" injected as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pageParam\"), \".\"), mdx(\"p\", null, \"However, the context also contains the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \" that is used for this query (and we're about to add more cool things to the context), which means you actually don't have to closure over things, as they will be provided for you by React Query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=query-function-context\",\n    \"metastring\": \"{1,3,12}\",\n    \"{1,3,12}\": true\n  }, \"const fetchTodos = async ({ queryKey }) => {\\n  // \\uD83D\\uDE80 we can get all params from the queryKey\\n  const [, state, sorting] = queryKey\\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\\n  return response.data\\n}\\n\\nexport const useTodos = () => {\\n  const { state, sorting } = useTodoParams()\\n\\n  // \\u2705 no need to pass parameters manually\\n  return useQuery(['todos', state, sorting], fetchTodos)\\n}\\n\")), mdx(\"p\", null, \"With this approach, you basically have no way of using any additional parameters in your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \" without also adding them to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \" \\uD83C\\uDF89.\"), mdx(\"h2\", {\n    \"id\": \"how-to-type-the-queryfunctioncontext\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"How to type the QueryFunctionContext\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#how-to-type-the-queryfunctioncontext\",\n    \"aria-label\": \"how to type the queryfunctioncontext permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"One of the ambitions for this approach was to get full type safety and infer the type of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryFunctionContext\"), \" from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \" passed to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \". This wasn't easy, but React Query supports that since \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/releases/tag/v3.13.3\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"v3.13.3\"), \". If you inline the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \", you'll see that the types are properly inferred (thank you, Generics):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=query-key-type-inference\",\n    \"metastring\": \"{6,9}\",\n    \"{6,9}\": true\n  }, \"export const useTodos = () => {\\n  const { state, sorting } = useTodoParams()\\n\\n  return useQuery(\\n    ['todos', state, sorting] as const,\\n    async ({ queryKey }) => {\\n      const response = await axios.get(\\n        // \\u2705 this is safe because the queryKey is a tuple\\n        `todos/${queryKey[1]}?sorting=${queryKey[2]}`\\n      )\\n      return response.data\\n    }\\n  )\\n}\\n\")), mdx(\"p\", null, \"This is nice and all, but still has a bunch of flaws:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can still just use whatever you have in the closure to build your query\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryKey\"), \" for building the url in the above way is still unsafe because you can stringify everything.\")), mdx(\"h3\", {\n    \"id\": \"query-key-factories\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Query Key Factories\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#query-key-factories\",\n    \"aria-label\": \"query key factories permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This is where query key factories come in again. If we have a typesafe query key factory to build our keys, we can use the return type of that factory to type our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryFunctionContext\"), \". Here's how that might look:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=typed-query-function-context\",\n    \"metastring\": \"{11,12,21}\",\n    \"{11,12,21}\": true\n  }, \"const todoKeys = {\\n  all: ['todos'] as const,\\n  lists: () => [...todoKeys.all, 'list'] as const,\\n  list: (state: State, sorting: Sorting) =>\\n    [...todoKeys.lists(), state, sorting] as const,\\n}\\n\\nconst fetchTodos = async ({\\n  queryKey,\\n}: // \\uD83E\\uDD2F only accept keys that come from the factory\\nQueryFunctionContext<ReturnType<typeof todoKeys['list']>>) => {\\n  const [, , state, sorting] = queryKey\\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\\n  return response.data\\n}\\n\\nexport const useTodos = () => {\\n  const { state, sorting } = useTodoParams()\\n\\n  // \\u2705 build the key via the factory\\n  return useQuery(todoKeys.list(state, sorting), fetchTodos)\\n}\\n\")), mdx(\"p\", null, \"The type \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryFunctionContext\"), \" is exported by React Query. It takes one generic, which defines the type of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \". In the above example, we set it to be equal to whatever the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"list\"), \" function of our key factory returns. Since we use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"the-power-of-const-assertions\"\n  }, \"const assertions\"), \", all our keys will be strictly typed tuples - so if we try to use a key that doesn't conform to that structure, we will get a type error.\"), mdx(\"h2\", {\n    \"id\": \"object-query-keys\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Object Query Keys\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#object-query-keys\",\n    \"aria-label\": \"object query keys permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"While slowly transitioning to the above approach, I noticed that array keys are not really performing that well. This becomes apparent when looking at how we destruct the query key now:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=weird-destruct\"\n  }, \"const [, , state, sorting] = queryKey\\n\")), mdx(\"p\", null, \"We basically leave out the first two parts (our hardcoded scopes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"todo\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"list\"), \") and only use the dynamic parts. Of course, it didn't take long until we added another scope at the beginning, which again led to wrongly built urls:\"), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"22.083333333333332%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA90lEQVQY0x3MyXKCQAAAUe9JyliWgARQWYZlWCcIsojEUIn//0Odioeud+vVy7vGdrvn7Anqk4dtnEjDnizsacsHhZw5Fz/kyfQ0i69EfoNmCnRHsLdd/h9vG53XjcaqMo+k5gGpf5DbPnXWoeKaczlR+SmfJ0HpeBSWy1y0fKueqagZZMnSDAyyItwaJLqFNGxWUnjEgY9/sImjGDUuVJeJenpQqIY8iZCRIBY+l6+W/t4x3yamcWTsO7q2QWUpUgT4R4fVLnExkoC1a7JLQtzxjtP2uNOCpRQfqWAvBVriYf7GHB45+W14ll17kqFFLTNBq1h7Fn+753hH/9ioKAAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"destruct query key\",\n    \"title\": \"destruct query key\",\n    \"src\": \"/blog/static/45281c9e1a8d84d36fd5e44bca8fbf36/7d769/destruct-query-key.png\",\n    \"srcSet\": [\"/blog/static/45281c9e1a8d84d36fd5e44bca8fbf36/5243c/destruct-query-key.png 240w\", \"/blog/static/45281c9e1a8d84d36fd5e44bca8fbf36/ab158/destruct-query-key.png 480w\", \"/blog/static/45281c9e1a8d84d36fd5e44bca8fbf36/7d769/destruct-query-key.png 960w\", \"/blog/static/45281c9e1a8d84d36fd5e44bca8fbf36/4e07d/destruct-query-key.png 1044w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(SmallCentered, {\n    mdxType: \"SmallCentered\"\n  }, \"Source: A PR I recently made\"), mdx(\"p\", null, \"Turns out, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"objects\"), \" solve this problem really well, because you can use named destructuring. Further, they have \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"no drawback\"), \" when used inside a query key, because fuzzy matching for query invalidation works the same for objects as for arrays. Have a look at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/blob/9e414e8b4f3118b571cf83121881804c0b58a814/src/core/utils.ts#L321-L338\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"partialDeepEqual\"), \" function if you're interested in how that works.\"), mdx(\"p\", null, \"Keeping that in mind, this is how I would construct my query keys with what I know today:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=object-keys\",\n    \"metastring\": \"{3-6,11}\",\n    \"{3-6,11}\": true\n  }, \"const todoKeys = {\\n  // \\u2705 all keys are arrays with exactly one object\\n  all: [{ scope: 'todos' }] as const,\\n  lists: () => [{ ...todoKeys.all[0], entity: 'list' }] as const,\\n  list: (state: State, sorting: Sorting) =>\\n    [{ ...todoKeys.lists()[0], state, sorting }] as const,\\n}\\n\\nconst fetchTodos = async ({\\n  // \\u2705 extract named properties from the queryKey\\n  queryKey: [{ state, sorting }],\\n}: QueryFunctionContext<ReturnType<typeof todoKeys['list']>>) => {\\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\\n  return response.data\\n}\\n\\nexport const useTodos = () => {\\n  const { state, sorting } = useTodoParams()\\n\\n  return useQuery(todoKeys.list(state, sorting), fetchTodos)\\n}\\n\")), mdx(\"p\", null, \"Object query keys even make your fuzzy matching capabilities more powerful, because they have no order. With the array approach, you can tackle everything todo related, all todo lists, or the todo list with a specific filter. With objects keys, you can do that too, but also tackle all lists (e.g. todo lists and profile lists) if you want to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=fuzzy-matching-with-object-keys\"\n  }, \"// \\uD83D\\uDD7A remove everything related to the todos feature\\nqueryClient.removeQueries([{ scope: 'todos' }])\\n\\n// \\uD83D\\uDE80 reset all todo lists\\nqueryClient.resetQueries([{ scope: 'todos', entity: 'list' }])\\n\\n// \\uD83D\\uDE4C invalidate all lists across all scopes\\nqueryClient.invalidateQueries([{ entity: 'list' }])\\n\")), mdx(\"p\", null, \"This can come in quite handy if you have multiple overlapping scopes that have a hierarchy, but where you still want to match everything belonging to the sub-scope.\"), mdx(\"h2\", {\n    \"id\": \"is-this-worth-it\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Is this worth it?\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#is-this-worth-it\",\n    \"aria-label\": \"is this worth it permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"As always: it depends. I've been loving this approach lately (which is why I wanted to share it with you), but there is certainly a tradeoff here between complexity and type safety. Composing query keys inside the key factory is slightly more complex (because \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKeys\"), \" still have to be an Array at the top level), and typing the context depending on the return type of the key factory is also not trivial. If your team is small, your api interface is slim and / or you're using plain JavaScript, you might not want to go that route. As per usual, choose whichever tools and approaches make the most sense for your specific situation \\uD83D\\uDE4C\"), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #…","timeToRead":5,"banner":{"childImageSharp":{"resize":{"src":"/static/f77f007a5cfde787408ed16d3fbab168/a6c62/context.jpg"}}}}},"pageContext":{"slug":"/leveraging-the-query-function-context","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}