{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/mastering-mutations-in-react-query",
    "result": {"data":{"post":{"slug":"/mastering-mutations-in-react-query","title":"Mastering Mutations in React Query","date":"09.10.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"Learn all about the concept of performing side effects on the server with React Query.","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mastering Mutations in React Query\",\n  \"description\": \"Learn all about the concept of performing side effects on the server with React Query.\",\n  \"date\": \"2021-10-09T00:00:00.000Z\",\n  \"banner\": \"./mutations.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAACAf/aAAwDAQACEAMQAAAB5rLUxAYRf//EABsQAQEAAQUAAAAAAAAAAAAAAAECAAMREiEx/9oACAEBAAEFApnE6QzT9oOFrv8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQESH/2gAIAQEABj8CnUM2f//EABoQAQADAQEBAAAAAAAAAAAAAAEAESFBMRD/2gAIAQEAAT8hzwjGg96QyWWl58ylQu+ZOr5P/9oADAMBAAIAAwAAABDML//EABcRAAMBAAAAAAAAAAAAAAAAAAABEWH/2gAIAQMBAT8QaJp//8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARUf/aAAgBAgEBPxAbTl//xAAaEAEBAAMBAQAAAAAAAAAAAAABEQAhMUHB/9oACAEBAAE/EL1GFAKve4aieAMvgBGoHhm7O5Jd97iIIxR8ZpbAATP/2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"mutations\",\n    \"title\": \"mutations\",\n    \"src\": \"/blog/static/e7fe4197241e1f30c5b0b6f2bc497c64/bbe0c/mutations.jpg\",\n    \"srcSet\": [\"/blog/static/e7fe4197241e1f30c5b0b6f2bc497c64/46946/mutations.jpg 240w\", \"/blog/static/e7fe4197241e1f30c5b0b6f2bc497c64/55489/mutations.jpg 480w\", \"/blog/static/e7fe4197241e1f30c5b0b6f2bc497c64/bbe0c/mutations.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Bra\\u0148o\",\n    url: \"https://unsplash.com/@3dparadise\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, \"We've covered a lot of ground already when it comes to the features and concepts React Query provides. Most of them are about \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"retrieving\"), \" data - via the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" hook. There is however a second, integral part to working with data: updating it.\"), mdx(\"p\", null, \"For this use-case, React Query offers the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" hook.\"), mdx(\"h2\", {\n    \"id\": \"what-are-mutations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"What are mutations?\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-are-mutations\",\n    \"aria-label\": \"what are mutations permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Generally speaking, mutations are functions that have a side effect. As an example, have a look at the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"push\"), \" method of Arrays: It has the side effect of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"changing\"), \" the array in place where you're pushing a value to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=mutable-array-push\"\n  }, \"const myArray = [1]\\nmyArray.push(2)\\n\\nconsole.log(myArray) // [1, 2]\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"immutable\"), \" counterpart would be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"concat\"), \", which can also add values to an array, but it will return a new Array instead of directly manipulating the Array you operate on:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=immutable-array-concat\"\n  }, \"const myArray = [1]\\nconst newArray = myArray.concat(2)\\n\\nconsole.log(myArray) //  [1]\\nconsole.log(newArray) // [1, 2]\\n\")), mdx(\"p\", null, \"As the name indicates, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" also has some sort of side effect. Since we are in the context of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"managing server state\"), \" with React Query, mutations describe a function that performs such a side effect \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"on the server\"), \". Creating a todo in your database would be a mutation. Logging in a user is also a classic mutation, because it performs the side effect of creating a token for the user.\"), mdx(\"p\", null, \"In some aspects, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" very similar to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \". In others, it is quite different.\"), mdx(\"h2\", {\n    \"id\": \"similarities-to-usequery\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Similarities to useQuery\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#similarities-to-usequery\",\n    \"aria-label\": \"similarities to usequery permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" will track the state of a mutation, just like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" does for queries. It'll give you \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"loading\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"error\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"status\"), \" fields to make it easy for you to display what's going on to your users.\"), mdx(\"p\", null, \"You'll also get the same nice callbacks that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" has: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"onSuccess\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"onError\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" onSettled\"), \". But that's about where the similarities end.\"), mdx(\"h2\", {\n    \"id\": \"differences-to-usequery\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Differences to useQuery\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#differences-to-usequery\",\n    \"aria-label\": \"differences to usequery permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(SpacingBox, {\n    mdxType: \"SpacingBox\"\n  }), mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, mdx(\"i\", null, \"useQuery\"), \" is declarative, \", mdx(\"i\", null, \"useMutation\"), \" is imperative.\"), mdx(\"p\", null, \"By that, I mean that queries mostly run automatically. You define the dependencies, but React Query takes care of running the query immediately, and then also performs smart background updates when deemed necessary. That works great for queries because we want to keep what we see on the screen \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"in sync\"), \" with the actual data on the backend.\"), mdx(\"p\", null, \"For mutations, that wouldn't work well. Imagine a new todo would be created every time you focus your browser window \\uD83E\\uDD28. So instead of running the mutation instantly, React Query gives you a function that you can invoke whenever you want to make the mutation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=imperative-mutate\"\n  }, \"function AddComment({ id }) {\\n  // this doesn't really do anything yet\\n  const addComment = useMutation((newComment) =>\\n    axios.post(`/posts/${id}/comments`, newComment)\\n  )\\n\\n  return (\\n    <form\\n      onSubmit={(event) => {\\n        event.preventDefault()\\n        // \\u2705 mutation is invoked when the form is submitted\\n        addComment.mutate(new FormData(event.currentTarget).get('comment'))\\n      }}\\n    >\\n      <textarea name=\\\"comment\\\" />\\n      <button type=\\\"submit\\\">Comment</button>\\n    </form>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Another difference is that mutations don't share state like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" does. You can invoke the same \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" call multiple times in different components and will get the same, cached result returned to you - but this won't work for mutations.\"), mdx(\"h2\", {\n    \"id\": \"tying-mutations-to-queries\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Tying mutations to queries\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#tying-mutations-to-queries\",\n    \"aria-label\": \"tying mutations to queries permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Mutations are, per design, not directly coupled to queries. A mutation that likes a blog post has no ties towards the query that fetches that blog post. For that to work, you would need some sort of underlying schema, which React Query doesn't have.\"), mdx(\"p\", null, \"To have a mutation reflect the changes it made on our queries, React Query primarily offers two ways:\"), mdx(\"h3\", {\n    \"id\": \"invalidation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Invalidation\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#invalidation\",\n    \"aria-label\": \"invalidation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This is conceptually the simplest way to get your screen up-to-date. Remember, with server state, you're only ever displaying a snapshot of data from a given point in time. React Query tries to keep that up-to-date of course, but if you're deliberately changing server state with a mutation, this is a great point in time to tell React Query that some data you have cached is now \\\"invalid\\\". React Query will then go and refetch that data if it's currently in use, and your screen will update automatically for you once the fetch is completed. The only thing you have to tell the library is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"which\"), \" queries you want to invalidate:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=invalidation-from-mutation\"\n  }, \"const useAddComment = (id) => {\\n  const queryClient = useQueryClient()\\n\\n  return useMutation(\\n    (newComment) => axios.post(`/posts/${id}/comments`, newComment),\\n    {\\n      onSuccess: () => {\\n        // \\u2705 refetch the comments list for our blog post\\n        queryClient.invalidateQueries(['posts', id, 'comments'])\\n      },\\n    }\\n  )\\n}\\n\")), mdx(\"p\", null, \"Query invalidation is pretty smart. Like all \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/filters#query-filters\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Query Filters\"), \", it uses fuzzy matching on the query key. So if you have multiple keys for your comments list, they will all be invalidated. However, only the ones that are currently active will be refetched. The rest will be marked as stale, which will cause them to be refetched the next time they are used.\"), mdx(\"p\", null, \"As an example, let's assume we have the option to sort our comments, and at the time the new comment was added, we have two queries with comments in our cache:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"['posts', 5, 'comments', { sortBy: ['date', 'asc'] }\\n['posts', 5, 'comments', { sortBy: ['author', 'desc'] }\\n\")), mdx(\"p\", null, \"Since we're only displaying one of them on the screen, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"invalidateQueries\"), \" will refetch that one and mark the other one as stale.\"), mdx(\"h3\", {\n    \"id\": \"direct-updates\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Direct updates\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#direct-updates\",\n    \"aria-label\": \"direct updates permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Sometimes, you don't want to refetch data, especially if the mutation already returns everything you need to know. If you have a mutation that updates the title of your blog post, and the backend returns the complete blog post as a response, you can update the query cache directly via \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setQueryData\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=update-from-mutation-response\"\n  }, \"const useUpdateTitle = (id) => {\\n  const queryClient = useQueryClient()\\n\\n  return useMutation(\\n    (newTitle) => axios.patch(`/posts/${id}`, { title: newTitle }),\\n    {\\n      // \\uD83D\\uDCA1 response of the mutation is passed to onSuccess\\n      onSuccess: (newPost) => {\\n        // \\u2705 update detail view directly\\n        queryClient.setQueryData(['posts', id], newPost)\\n      },\\n    }\\n  )\\n}\\n\")), mdx(\"p\", null, \"Putting data into the cache directly via \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setQueryData\"), \" will act as if this data was returned from the backend, which means that all components using that query will re-render accordingly.\"), mdx(\"p\", null, \"I'm showing some more examples of direct updates and the combination of both approaches in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"effective-react-query-keys#structure\"\n  }, \"#8: Effective React Query Keys\"), \".\"), mdx(\"hr\", null), mdx(\"p\", null, \"I personally think that most of the time, invalidation should be preferred. Of course, it depends on the use-case, but for direct updates to work reliably, you need more code on the frontend, and to some extent duplicate logic from the backend. Sorted lists are for example pretty hard to update directly, as the position of my entry could've potentially changed because of the update. Invalidating the whole list is the \\\"safer\\\" approach.\"), mdx(\"h2\", {\n    \"id\": \"optimistic-updates\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Optimistic updates\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#optimistic-updates\",\n    \"aria-label\": \"optimistic updates permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Optimistic updates are one of the key selling points for using React Query mutations. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" cache give us data instantly when switching between queries, especially when combined with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/prefetching\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"prefetching\"), \". Our whole UI feels very snappy because of it, so why not get the same advantage for mutations as well?\"), mdx(\"p\", null, \"A lot of the time, we are quite certain that an update will go through. Why should the user wait for a couple of seconds until we get the okay from the backend to show the result in the UI? The idea of optimistic updates is to fake the success of a mutation even before we have sent it to the server. Once we get a successful response back, all we have to do is invalidate our view again to see the real data. In case the request fails, we're going to roll back our UI to the state from before the mutation.\"), mdx(\"p\", null, \"This works great for small mutations where instant user feedback is actually required. There is nothing worse than having a toggle button that performs a request, and it doesn't react at all until the request has completed. Users will double or even triple click that button, and it will just feel \\\"laggy\\\" all over the place.\"), mdx(\"h3\", {\n    \"id\": \"example\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Example\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#example\",\n    \"aria-label\": \"example permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I've decided to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" show an additional example. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/optimistic-updates\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"official docs\"), \" cover that topic very well, and they also have a codesandbox example \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/examples/optimistic-updates\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"in JavaScript\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/examples/optimistic-updates-typescript\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"in TypeScript\"), \".\"), mdx(\"p\", null, \"I further think that optimistic updates are a bit over-used. Not every mutation needs to be done optimistically. You should really be sure that it rarely fails, because the UX for a rollback is not great. Imagine a Form in a Dialog that closes when you submit it, or a redirect from a detail view to a list view after an update. If those are done prematurely, they are hard to undo.\"), mdx(\"p\", null, \"Also, be sure that the instant feedback is really required (like in the toggle button example above). The code needed to make optimistic updates work is non-trivial, especially compared to \\\"standard\\\" mutations. You need to mimic what the backend is doing when you're faking the result, which can be as easy as flipping a Boolean or adding an item to an Array, but it might also get more complex really fast:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the todo you're adding needs an id, where do you get it from?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the list you're currently viewing is sorted, will you insert the new entry at the right position?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What if another user has added something else in the meantime - will our optimistically added entry switch positions after a refetch?\")), mdx(\"p\", null, \"All these edge cases might make the UX actually worse in some situations, where it might be enough to disable the button and show a loading animation while the mutation is in-flight. As always, choose the right tool for the right job.\"), mdx(\"h2\", {\n    \"id\": \"common-gotchas\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Common Gotchas\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#common-gotchas\",\n    \"aria-label\": \"common gotchas permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Finally, let's dive into some things that are good to know when dealing with mutations that might not be that obvious initially:\"), mdx(\"h3\", {\n    \"id\": \"awaited-promises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"awaited Promises\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#awaited-promises\",\n    \"aria-label\": \"awaited promises permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Promises returned from the mutation callbacks are awaited by React Query, and as it so happens, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"invalidateQueries\"), \" returns a Promise. If you want your mutation to stay in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"loading\"), \" state while your related queries update, you have to return the result of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"invalidateQueries\"), \" from the callback:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=awaited-promises\"\n  }, \"{\\n  // \\uD83C\\uDF89 will wait for query invalidation to finish\\n  onSuccess: () => {\\n    return queryClient.invalidateQueries(['posts', id, 'comments'])\\n  }\\n}\\n{\\n  // \\uD83D\\uDE80 fire and forget - will not wait\\n  onSuccess: () => {\\n    queryClient.invalidateQueries(['posts', id, 'comments'])\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"mutate-or-mutateasync\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Mutate or MutateAsync\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#mutate-or-mutateasync\",\n    \"aria-label\": \"mutate or mutateasync permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" gives you two functions - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutateAsync\"), \". What's the difference, and when should you use which one?\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" doesn't return anything, while \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutateAsync\"), \" returns a Promise containing the result of the mutation. So you might be tempted to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutateAsync\"), \" when you need access to the mutation response, but I would still argue that you should almost always use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \".\"), mdx(\"p\", null, \"You can still get access to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" or the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"error\"), \" via the callbacks, and you don't have to worry about error handling: Since \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutateAsync\"), \" gives you control over the Promise, you also have to catch errors manually, or you might get an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/40500490/what-is-an-unhandled-promise-rejection\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"unhandled promise rejection\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=accessing-mutation-data\"\n  }, \"const onSubmit = () => {\\n  // \\u2705 accessing the response via onSuccess\\n  myMutation.mutate(someData, {\\n    onSuccess: (data) => history.push(data.url),\\n  })\\n}\\n\\nconst onSubmit = async () => {\\n  // \\uD83D\\uDEA8 works, but is missing error handling\\n  const data = await myMutation.mutateAsync(someData)\\n  history.push(data.url)\\n}\\n\\nconst onSubmit = async () => {\\n  // \\uD83D\\uDE15 this is okay, but look at the verbosity\\n  try {\\n    const data = await myMutation.mutateAsync(someData)\\n    history.push(data.url)\\n  } catch (error) {\\n    // do nothing\\n  }\\n}\\n\")), mdx(\"p\", null, \"Handling errors is not necessary with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \", because React Query catches (and discards) the error for you internally. It is literally implemented with: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutateAsync().catch(noop)\"), \"\\uD83D\\uDE0E\"), mdx(\"p\", null, \"The only situations where I've found \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutateAsync\"), \" to be superior is when you really need the Promise for the sake of having a Promise. This can be necessary if you want to fire off multiple mutations concurrently and want to wait for them all to be finished, or if you have dependent mutations where you'd get into callback hell with the callbacks.\"), mdx(\"h3\", {\n    \"id\": \"mutations-only-take-one-argument-for-variables\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Mutations only take one argument for variables\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#mutations-only-take-one-argument-for-variables\",\n    \"aria-label\": \"mutations only take one argument for variables permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Since the last argument to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" is the options object, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" can currently only take \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"one\"), \" argument for variables. This is certainly a limitation, but it can be easily worked around by using an object:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=multiple-variables\"\n  }, \"// \\uD83D\\uDEA8 this is invalid syntax and will NOT work\\nconst mutation = useMutation((title, body) => updateTodo(title, body))\\nmutation.mutate('hello', 'world')\\n\\n// \\u2705 use an object for multiple variables\\nconst mutation = useMutation(({ title, body }) => updateTodo(title, body))\\nmutation.mutate({ title: 'hello', body: 'world' })\\n\")), mdx(\"p\", null, \"To read more on why that is currently necessary, have a look at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/discussions/1226\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"this discussion\"), \".\"), mdx(\"h3\", {\n    \"id\": \"some-callbacks-might-not-fire\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Some callbacks might not fire\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#some-callbacks-might-not-fire\",\n    \"aria-label\": \"some callbacks might not fire permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"You can have callbacks on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" as well as on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" itself. It is important to know that the callbacks on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" fire before the callbacks on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \". Further, the callbacks on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mutate\"), \" might not fire \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"at all\"), \" if the component unmounts before the mutation has finished.\"), mdx(\"p\", null, \"That's why I think it's a good practice to separate concerns in your callbacks:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Do things that are absolutely necessary and logic related (like query invalidation) in the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"useMutation\"), \" callbacks.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Do UI related things like redirects or showing toast notifications in \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"mutate\"), \" callbacks. If the user navigated away from the current screen before the mutation finished, those will purposefully not fire.\")), mdx(\"p\", null, \"This separation is especially neat if \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" comes from a custom hook, as this will keep query related logic in the custom hook while UI related actions are still in the UI. This also makes the custom hook more reusable, because how you interact with the UI might vary on a case by case basis - but the invalidation logic will likely always be the same:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=separate-concerns\"\n  }, \"const useUpdateTodo = () =>\\n  useMutation(updateTodo, {\\n    // \\u2705 always invalidate the todo list\\n    onSuccess: () => {\\n      queryClient.invalidateQueries(['todos', 'list'])\\n    },\\n  })\\n\\n// in the component\\n\\nconst updateTodo = useUpdateTodo()\\nupdateTodo.mutate(\\n  { title: 'newTitle' },\\n  // \\u2705 only redirect if we're still on the detail page\\n  // when the mutation finishes\\n  { onSuccess: () => history.push('/todos') }\\n)\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #…","timeToRead":7,"banner":{"childImageSharp":{"resize":{"src":"/static/e7fe4197241e1f30c5b0b6f2bc497c64/a6c62/mutations.jpg"}}}}},"pageContext":{"slug":"/mastering-mutations-in-react-query","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}