{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/simplifying-use-effect",
    "result": {"data":{"post":{"slug":"/simplifying-use-effect","title":"Simplifying useEffect","date":"23.01.2021","tags":[{"name":"React","slug":"react"},{"name":"useEffect","slug":"use-effect"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"useEffect hooks can be hard to reason about, but I have 5 principles that can help to manage them","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Simplifying useEffect\",\n  \"description\": \"useEffect hooks can be hard to reason about, but I have 5 principles that can help to manage them\",\n  \"date\": \"2021-01-23T00:00:00.000Z\",\n  \"banner\": \"./effect.jpg\",\n  \"tags\": [\"React\", \"useEffect\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFAv/EABQBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAZDqNJDI4F//xAAYEAEAAwEAAAAAAAAAAAAAAAABAAIDEf/aAAgBAQABBQJWYpWaHLkwe30uNv/EABYRAQEBAAAAAAAAAAAAAAAAAAEAEv/aAAgBAwEBPwELLf/EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPwG1r//EABoQAAIDAQEAAAAAAAAAAAAAAAARATFRIaH/2gAIAQEABj8CsavhIyMwr0//xAAbEAADAAMBAQAAAAAAAAAAAAAAARExQVEhcf/aAAgBAQABPyFDZ3I8Skxi30aNRsqGlxwUVr4P/9oADAMBAAIAAwAAABDnP//EABYRAQEBAAAAAAAAAAAAAAAAADEQEf/aAAgBAwEBPxDcZ//EABYRAAMAAAAAAAAAAAAAAAAAAAARMf/aAAgBAgEBPxBFgp//xAAbEAEBAQEAAwEAAAAAAAAAAAABESEAMUFRgf/aAAgBAQABPxC9kfta87s0ptCLzmnwGcD1JU5ITtEZRv7nV3JJhinzv//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"effect\",\n    \"title\": \"effect\",\n    \"src\": \"/blog/static/960520b8aca100dc6d09523b58ca14b7/bbe0c/effect.jpg\",\n    \"srcSet\": [\"/blog/static/960520b8aca100dc6d09523b58ca14b7/46946/effect.jpg 240w\", \"/blog/static/960520b8aca100dc6d09523b58ca14b7/55489/effect.jpg 480w\", \"/blog/static/960520b8aca100dc6d09523b58ca14b7/bbe0c/effect.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Christopher Burns\",\n    url: \"https://unsplash.com/@christopher__burns\",\n    mdxType: \"Attribution\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/hooks-reference.html#useeffect\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"useEffect\"), \". The hook everybody needs, but nobody wants. According to the official react docs, it's \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"an escape hatch from React\\u2019s purely functional world into the imperative world\"), \"\\\". The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://overreacted.io/a-complete-guide-to-useeffect/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"complete guide to useEffect\"), \" by Redux author and React core team member \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/dan_abramov\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Dan Abramov\"), \" is a 49 minute read - and it takes at least twice the time to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"really\"), \" comprehend it.\"), mdx(\"p\", null, \"useEffect is about as complex as it can get in ReactJs, and it is very unlikely that you can write an application without it. So let's try and apply some good principles to make working with useEffect more manageable:\"), mdx(\"h2\", {\n    \"id\": \"1-write-fewer-effects\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"1. Write fewer effects\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#1-write-fewer-effects\",\n    \"aria-label\": \"1 write fewer effects permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I've already written about a couple of ways to reduce the amount of effects in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./tags/use-state-pitfalls\"\n  }, \"useState pitfalls series\"), \":\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./dont-over-use-state\"\n  }, \"part 1\"), \", we've established that some effects can be replaced with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"useMemo\"), \" or even just normal function executions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"./putting-props-to-use-state\"\n  }, \"part 2\"), \", I've outlined why trying to sync different react states with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"useEffect\"), \" is likely an anti-pattern and what you can do instead.\")), mdx(\"h3\", {\n    \"id\": \"data-fetching\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Data fetching\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#data-fetching\",\n    \"aria-label\": \"data fetching permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Data fetching is a very common side effect that is typically managed with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \". After all, most apps need to fetch data from somewhere. The scenario is so common that there are some very good libraries out there that will not only help you to make the complex logic more declarative, they will also give you a bunch of great additional features.\"), mdx(\"p\", null, \"I'm obviously going to recommend my favourite open source library, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"react-query\"), \" (I doubt that I will be able to write another article without mentioning it \\uD83D\\uDE05), but \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://swr.vercel.app/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"SWR\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://apollographql.com/client\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Apollo\"), \" and also \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://rtk-query-docs.netlify.app/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"RTK-Query\"), \" are great as well. The point is: don't try and re-invent the wheel. Some problems have been solved before and are worth abstracting away. The amount of useEffects that I've had to write has been drastically reduced since I'm using react-query.\"), mdx(\"h2\", {\n    \"id\": \"2-follow-the-singe-responsibility-principle\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"2. Follow the singe responsibility principle\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#2-follow-the-singe-responsibility-principle\",\n    \"aria-label\": \"2 follow the singe responsibility principle permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"A function or a class should do one thing, and one thing only. Your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"processPayment\"), \" function is hopefully only going to process the payment and not additionally redirecting the user somewhere, because that is not it's responsibility. The same principle applies to the function that you pass to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \". There is no need to tuck everything in one \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=one-effect-two-responsibilities\"\n  }, \"React.useEffect(() => {\\n  document.title = 'hello world'\\n  trackPageVisit()\\n}, [])\\n\")), mdx(\"p\", null, \"Here, we want to perform some operations, like setting the document title and tracking a page visit with some analytics tool, when the component \\\"mounts\\\". While it may seem minor at first glance, we are doing two very different things in this one effect, and it could easily be split into two effects. The advantage becomes more apparent as dependencies of the effect change over time.\"), mdx(\"p\", null, \"Suppose we now want to add a feature that syncs some local state with the document title:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=sync-title\",\n    \"metastring\": \"{1,4,6}\",\n    \"{1,4,6}\": true\n  }, \"const [title, setTitle] = React.useState('hello world')\\n\\nReact.useEffect(() => {\\n  document.title = title\\n  trackPageVisit()\\n}, [title])\\n\")), mdx(\"p\", null, \"Can you spot the bug? Every time the title changes, we are also tracking a page visit, which is probably not what we intended. Spitting it into two effects solves the problem, and I believe we should have done so right from the beginning:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=single-responsibility\"\n  }, \"const [title, setTitle] = React.useState('hello world')\\n\\nReact.useEffect(() => {\\n  document.title = title\\n}, [title])\\n\\nReact.useEffect(() => {\\n  trackPageVisit()\\n}, [])\\n\")), mdx(\"p\", null, \"Not only is the code now less buggy, it is also easier to reason about. Each effect is now half the size, so you can look at each one in isolation to better grasp what it is doing.\"), mdx(\"h2\", {\n    \"id\": \"3-write-custom-hooks\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"3. Write custom hooks\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#3-write-custom-hooks\",\n    \"aria-label\": \"3 write custom hooks permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I really don't like components where 50% of the code is hook calls. It usually shows that we are mixing our logic with our markup. Tucking them away in a custom hook has multiple advantages, apart from the obvious \\\"you can reuse them\\\":\"), mdx(\"h3\", {\n    \"id\": \"you-can-name-them\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"You can name them\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#you-can-name-them\",\n    \"aria-label\": \"you can name them permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Giving variables and functions \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./on-naming-things\"\n  }, \"a good name\"), \" is like writing documentation, and the same applies to hooks. If you are using TypeScript, you will also benefit from a clearly defined interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=named-hooks\"\n  }, \"const useTitleSync = (title: string) => {\\n  React.useEffect(() => {\\n    document.title = title\\n  }, [title])\\n}\\n\\nconst useTrackVisit = () => {\\n  React.useEffect(() => {\\n    trackPageVisit()\\n  }, [])\\n}\\n\")), mdx(\"p\", null, \"All our effects are now nicely hidden inside custom hooks with descriptive names. Our component will only have two lines of hook calls instead of six, which means it is more focussed on its main responsibility: producing markup.\"), mdx(\"h3\", {\n    \"id\": \"you-can-encapsulate-logic\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"You can encapsulate logic\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#you-can-encapsulate-logic\",\n    \"aria-label\": \"you can encapsulate logic permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This is probably the biggest advantage of custom hooks for me: We can tie things together that belong together, and we don't have to expose everything. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useTitleSync\"), \" hook is not ideal: it only covers the effect, and each component still needs to manage that title manually. So why don't we put \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"everything\"), \" title related in the custom hook to encapsulate all the logic with it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=useTitle\",\n    \"metastring\": \"{1-2,8}\",\n    \"{1-2,8}\": true\n  }, \"const useTitle = (initialTitle: string) => {\\n  const [title, setTitle] = React.useState(initialTitle)\\n\\n  React.useEffect(() => {\\n    document.title = title\\n  }, [title])\\n\\n  return [title, setTitle] as const\\n}\\n\")), mdx(\"p\", null, \"We can even take this one step further: If we only intend to show the title in the document title and nowhere else, we can keep the title value in the hook and expose only the setter, producing a minimal interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=encapsulated-value\",\n    \"metastring\": \"{8}\",\n    \"{8}\": true\n  }, \"const useTitle = (initialTitle: string) => {\\n  const [title, setTitle] = React.useState(initialTitle)\\n\\n  React.useEffect(() => {\\n    document.title = title\\n  }, [title])\\n\\n  return setTitle\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"you-can-test-them-in-isolation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"You can test them in isolation\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#you-can-test-them-in-isolation\",\n    \"aria-label\": \"you can test them in isolation permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Testing the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useTitle\"), \" hook without having to test the component that uses it has the advantage that you don't have to think about all the other things that are going on in that component, like page tracking. Testing custom hooks is very similar to testing any other util function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=testing-custom-hooks\"\n  }, \"import { act, renderHook } from '@testing-library/react-hooks'\\n\\ndescribe('useTitle', () => {\\n  test('sets the document title', () => {\\n    const { result } = renderHook(() => useTitle('hello'))\\n    expect(document.title).toEqual('hello')\\n\\n    act(() => result.current('world'))\\n    expect(document.title).toEqual('world')\\n  })\\n})\\n\")), mdx(\"h2\", {\n    \"id\": \"4-give-them-names\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"4. Give them names\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#4-give-them-names\",\n    \"aria-label\": \"4 give them names permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"All the above reasons make me want to write custom hooks even if I only use them once. But if you cannot or don't want to extract it to a custom hook for whatever reason, the function passed to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" can still have a name, so consider naming your effects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=named-effect\"\n  }, \"const [title, setTitle] = React.useState('hello world')\\n\\nReact.useEffect(fuction syncTitle() {\\n  document.title = title\\n}, [title])\\n\")), mdx(\"h2\", {\n    \"id\": \"5-dont-lie-about-dependencies\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"5. Don't lie about dependencies\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#5-dont-lie-about-dependencies\",\n    \"aria-label\": \"5 dont lie about dependencies permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Not even, or actually especially not, for functions. I will just defer to Dan here, because I cannot describe it better than he already does in his \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://overreacted.io/a-complete-guide-to-useeffect/#dont-lie-to-react-about-dependencies\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"complete guide\"), \".\"), mdx(\"p\", null, \"One additional thing that I think is worth mentioning is: not every effect needs dependencies. I've seen effects with 8+ dependencies, some of them being objects that are not memoized, so they will trigger the effect in every render anyways. So why bother, the second argument of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" is optional after all. This comes in handy if your effect uses early returns or executes the side effect conditionally:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:use-initialize-payload\"\n  }, \"const useInitializePayload = () => {\\n  const payload = usePayload()\\n  React.useEffect(() => {\\n    if (payload === null) {\\n      performSomeSideEffectThatInitializesPayload(value1, value2, ...valueN)\\n    }\\n  })\\n}\\n\")), mdx(\"p\", null, \"The dependency array for this effect would probably be quite large, or we could try to cheat with just \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[payload]\"), \" as dependency. I find both ways to be inferior to just always running the effect and aborting if necessary.\"), mdx(Comments, {\n    mdxType: \"Comments\"\n  }, \"I hope these tips will reduce complexity for you when working with\", ' ', mdx(\"i\", null, \"useEffect\"), \". Let me know in the comments below how you prefer to organize your effects \\u2B07\\uFE0F\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"useEffect . The hook everybody needs, but nobody wants. According to the official react docs, it's \" an escape hatch from React’s purely…","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/960520b8aca100dc6d09523b58ca14b7/a6c62/effect.jpg"}}}}},"pageContext":{"slug":"/simplifying-use-effect","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}