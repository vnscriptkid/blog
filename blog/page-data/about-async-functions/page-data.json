{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/about-async-functions",
    "result": {"data":{"post":{"slug":"/about-async-functions","title":"About async functions","date":"23.07.2021","tags":[{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"A deep dive into async functions and how they are different from promise chaining","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"About async functions\",\n  \"description\": \"A deep dive into async functions and how they are different from promise chaining\",\n  \"date\": \"2021-07-23T00:00:00.000Z\",\n  \"banner\": \"./async.jpeg\",\n  \"tags\": [\"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"124.58333333333333%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAwAFBP/EABcBAAMBAAAAAAAAAAAAAAAAAAECAwD/2gAMAwEAAhADEAAAAUdBxy5pAzZ7NXsinl//xAAdEAABBAIDAAAAAAAAAAAAAAABAAIDEhEzEyIx/9oACAEBAAEFAoWFwkyE71lOEA2ee16RQzZRIcmbIt5X/8QAGBEAAgMAAAAAAAAAAAAAAAAAARADERL/2gAIAQMBAT8BUoyaX//EABcRAAMBAAAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8BNYp//8QAHRAAAgICAwEAAAAAAAAAAAAAAAERIRAxE0FRgf/aAAgBAQAGPwKSMV2Obo0QrNS/SeJP7hY//8QAHhAAAgICAgMAAAAAAAAAAAAAAREAITFBEGFRcbH/2gAIAQEAAT8hQGB5gII61KXhgBJmjOXDwDagm0/alY/ZZjSCoyOYddvfE+qa+p//2gAMAwEAAgADAAAAEAPQQP/EABgRAAMBAQAAAAAAAAAAAAAAAAABESEx/9oACAEDAQE/EJlIVV4in//EABcRAQEBAQAAAAAAAAAAAAAAAAABEWH/2gAIAQIBAT8QcEZWP//EAB8QAQACAgICAwAAAAAAAAAAAAEAESExQVFxsYGh0f/aAAgBAQABPxCqwFVqpVNjDhCoWGILBQ8vhFBBFl43bBEXDlS4kK7zg311+TeYUT5GscSwkA2E1eH3Pu+jNof/2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"async\",\n    \"title\": \"async\",\n    \"src\": \"/blog/static/bfc273b3e8e4b70ebd2f4c4cc43b42dd/bbe0c/async.jpg\",\n    \"srcSet\": [\"/blog/static/bfc273b3e8e4b70ebd2f4c4cc43b42dd/46946/async.jpg 240w\", \"/blog/static/bfc273b3e8e4b70ebd2f4c4cc43b42dd/55489/async.jpg 480w\", \"/blog/static/bfc273b3e8e4b70ebd2f4c4cc43b42dd/bbe0c/async.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"WanderLabs\",\n    url: \"https://unsplash.com/@wanderlabs\",\n    mdxType: \"Attribution\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Async functions\"), \" are great, especially if you have to call multiple functions in a row that return promises. With async / await, code becomes easier to reason about for humans, because the data flow mimics synchronous code, which is what we are used to reading.\"), mdx(\"p\", null, \"So what are async functions exactly?\"), mdx(\"h2\", {\n    \"id\": \"syntactic-sugar\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Syntactic sugar\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#syntactic-sugar\",\n    \"aria-label\": \"syntactic sugar permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"When I first learned about async functions, the following sentence stuck with me:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Async / await is \\\"just\\\" syntactic sugar for promise chaining\")), mdx(\"p\", {\n    style: {\n      \"paddingLeft\": \"3rem\",\n      \"marginTop\": \"-1rem\"\n    }\n  }, \"\\u2014 Someone, somewhen\"), mdx(\"p\", null, \"This is mostly true, and if that's your mental model about async functions, it will get you quite far. To re-iterate, let's take an example and refactor it from promise chaining to an async function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=promise-chaining\"\n  }, \"function fetchTodos() {\\n  return fetch('/todos')\\n    .then(response => response.json())\\n    .then(json => json.data)\\n}\\n\")), mdx(\"p\", null, \"So far, so good. Nothing too difficult here, just our normal data fetching and extracting (error handling left out intentionally here). Still, even with this example, the callbacks are not so easy to read, so how would this look with an async function?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=async-function\"\n  }, \"async function fetchTodos() {\\n  const response = await fetch('/todos')\\n  const json = await response.json()\\n  return json.data\\n}\\n\")), mdx(\"p\", null, \"Ah, I believe that reads a lot better, because you can actually see where we are assigning variables to and what will be the final return value of that function.\"), mdx(\"p\", null, \"So, if that is a good mental model for async functions, what's the problem with the above definition? Well, it's just not everything. There are a couple of subtle difference between promise chaining and async functions that I learned the hard way. Let's go through them:\"), mdx(\"h2\", {\n    \"id\": \"they-always-return-a-promise\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"They always return a promise\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#they-always-return-a-promise\",\n    \"aria-label\": \"they always return a promise permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This is actually \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the\"), \" defining trait of an async function. No matter what you do, it will always return a promise, even if you don't explicitly return one:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=promisify\"\n  }, \"async function fetchRandom() {\\n  // \\u2705 this will return `Promise<number>`\\n  return Math.random()\\n}\\n\")), mdx(\"p\", null, \"This is necessary because you can use the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"await\"), \" keyword in async functions, and once you do that, you enter promise-land, in which there is no escaping from. If code is async, you can't turn it back to sync code. I was personally quite confused by this, because in scala, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.scala-lang.org/overviews/core/futures.html#blocking-outside-the-future\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Await.result\"), \" actually takes a promise, blocks the execution for a certain amount of time and then lets you continue synchronously with the resolved value.\"), mdx(\"p\", null, \"In JavaScript however, an async function will stay asynchronous, so the return value \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"must\"), \" be a promise, and the language construct makes sure of this out of the box. This brings us to the next point:\"), mdx(\"h2\", {\n    \"id\": \"it-transforms-thrown-errors-into-rejected-promises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"It transforms thrown Errors into rejected promises\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#it-transforms-thrown-errors-into-rejected-promises\",\n    \"aria-label\": \"it transforms thrown errors into rejected promises permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"You might have seen this in example code involving \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"the fetch API\"), \", as fetch will not automatically give you a failed promise on erroneous status codes like other libraries, e.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://axios-http.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"axios\"), \", do. To get to a failed promise, you just throw an Error (or anything, really), which will then be transformed into a failed promise. This is happening because, again, an async function always needs to return a promise:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=throw\"\n  }, \"async function fetchTodos() {\\n  const response = await fetch('/todos')\\n  if (!response.ok) {\\n    // \\u2705 this will become a failed promise\\n    throw new Error('Network response was not ok')\\n  }\\n  return response.json()\\n}\\n\")), mdx(\"p\", null, \"Now the same works if you are in a promise chain, but not if you are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"outside\"), \" of it. Suppose you want to do some parameter validation and decide to throw an Error if the input is invalid in a non-async function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=parameter-validation\"\n  }, \"function fetchTodo(id: number | undefined) {\\n  if (!id) {\\n    // \\uD83D\\uDEA8 this will NOT give you a failed promise\\n    throw new Error(\\\"expected id\\\")\\n  }\\n  return fetch('/todos')\\n    .then(response => response.json())\\n    .then(json => json.data)\\n}\\n\")), mdx(\"p\", null, \"If you make the same function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"async\"), \", it would give you a failed promise. These little nuances can be quite confusing, so I prefer to explicitly work with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Promise.reject\"), \" no matter which context I'm in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=parameter-explicit-promise-rejection\"\n  }, \"function fetchTodo(id: number | undefined) {\\n  if (!id) {\\n    // \\u2705 this will work as expected, no matter where\\n    return Promise.reject(new Error(\\\"expected id\\\"))\\n  }\\n  return fetch('/todos')\\n    .then(response => response.json())\\n    .then(json => json.data)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"they-always-return-a-new-promise\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"They always return a \", mdx(\"em\", {\n    parentName: \"h2\"\n  }, \"new\"), \" promise\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#they-always-return-a-new-promise\",\n    \"aria-label\": \"they always return a new promise permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I first stumbled upon this when working with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/query-cancellation\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"query cancellation in react-query\"), \". Here, react-query wants us to attach a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".cancel\"), \" method on our resulting promise. Surprisingly, this doesn't quite work in async functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=query-cancellation\"\n  }, \"async function fetchTodos() {\\n  const controller = new AbortController()\\n  const signal = controller.signal\\n\\n  const promise = fetch('/todos', {\\n    signal,\\n  })\\n\\n  promise.cancel = () => controller.abort()\\n  // \\uD83D\\uDEA8 This will be a new promise without the cancel method!\\n  return promise\\n}\\n\")), mdx(\"p\", null, \"Because we are in an async function, a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"new\"), \" promise will be returned at the end of it, even if we already return a promise ourselves! \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.carlrippon.com/cancelling-requests-with-react-query/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Here\"), \" is a great article if you want to see how query cancellation can work even with async functions.\"), mdx(\"h2\", {\n    \"id\": \"handling-errors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Handling errors\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#handling-errors\",\n    \"aria-label\": \"handling errors permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The default way of handling errors in async functions is with try / catch, which I don't like very much, mainly because the scope of try / catches seems to get very large. If additional, synchronous code happens \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" the async operation that might fail, we are likely still treating it as if the fetch failed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=error-handling\"\n  }, \"const fetchTodos = async (): Promise<Todos | undefined> => {\\n  try {\\n    const response = await axios.get('/todos')\\n    // \\uD83D\\uDEA8 if transform fails, we will catch it and show a toast :(\\n    return transform(response.data)\\n  } catch (error) {\\n    showToast(\\\"Fetch failed: \\\" + error.message)\\n    return undefined\\n  }\\n}\\n\")), mdx(\"p\", null, \"Sometimes, we even silently catch and discard the error, which will make debugging very hard.\"), mdx(\"p\", null, \"So if you also think that async / await is cool, but try / catch is not, you can try combining async functions with \\\"traditional\\\" catch methods:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=await-and-catch\"\n  }, \"const fetchTodos = async (): Promise<Todos | undefined> => {\\n  const response = await axios.get('/todos').catch(error => {\\n    // \\uD83D\\uDE80 showing the toast is scoped to catching the response error\\n    showToast(\\\"Fetch failed: \\\" + error.message)\\n    return undefined\\n  })\\n  return transform(response?.data)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"in-summary\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In summary\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#in-summary\",\n    \"aria-label\": \"in summary permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I hope this gives you a bit of a deeper understanding of what async / await is doing under the hood. I have seen lots of code where the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"async\"), \" keyword is just stuck on a function for no good reason, so lastly, here are some examples of patterns that I think should be avoided:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=weird-combos\"\n  }, \"// \\uD83D\\uDEA8 the async keyword doesn't do anything -\\n// except creating a new unneccessary promise\\nconst fetchTodos = async () => axios.get('/todos')\\n\\nconst fetchTodos = async () => {\\n  const response = await axios.get('/todos')\\n  // \\u26A0\\uFE0F awaiting a non-promise is possible, but doesn't do anything\\n  return await response.data\\n}\\n\\n// \\uD83D\\uDE48 I don't even \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nconst fetchTodos = async () =>\\n  await axios.get('/todos').then(response => response.data)\\n\\nconst fetchTodos = async () => {\\n  try {\\n    // \\uD83D\\uDEA8 await is redundant here, too\\n    return await axios.get('/todos')\\n  } catch (error) {\\n    // \\uD83D\\uDEA8 the catch-and-throw is totally unnecessary\\n    throw error\\n  }\\n}\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Async functions  are great, especially if you have to call multiple functions in a row that return promises. With async / await, code…","timeToRead":3,"banner":{"childImageSharp":{"resize":{"src":"/static/bfc273b3e8e4b70ebd2f4c4cc43b42dd/a6c62/async.jpg"}}}}},"pageContext":{"slug":"/about-async-functions","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}