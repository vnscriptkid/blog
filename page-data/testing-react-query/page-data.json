{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/testing-react-query",
    "result": {"data":{"post":{"slug":"/testing-react-query","title":"Testing React Query","date":"04.04.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"Let's take a look at how to efficiently test custom useQuery hooks and components using them.","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Testing React Query\",\n  \"description\": \"Let's take a look at how to efficiently test custom useQuery hooks and components using them.\",\n  \"date\": \"2021-04-04T00:00:00.000Z\",\n  \"banner\": \"./testing.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEA//EABYBAQEBAAAAAAAAAAAAAAAAAAIAAf/aAAwDAQACEAMQAAABq2Ryoygt/8QAGhAAAgIDAAAAAAAAAAAAAAAAAREAAhASIf/aAAgBAQABBQI26Jd7IYZf/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERUf/aAAgBAwEBPwFlWH//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARL/2gAIAQIBAT8BjL//xAAZEAACAwEAAAAAAAAAAAAAAAAQIQABMqH/2gAIAQEABj8CQzw25//EABwQAAICAgMAAAAAAAAAAAAAAAABEUEQITFRYf/aAAgBAQABPyG00NKTN+FfomrFI56P/9oADAMBAAIAAwAAABCc/wD/xAAYEQACAwAAAAAAAAAAAAAAAAAAEQEhUf/aAAgBAwEBPxBVRpA//8QAFREBAQAAAAAAAAAAAAAAAAAAAHH/2gAIAQIBAT8QKf/EABsQAQEAAgMBAAAAAAAAAAAAAAERACExQVGB/9oACAEBAAE/EEDBGk5rge4XH9ALuXXW8zVwDrWEXUMDqZ//2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"testing\",\n    \"title\": \"testing\",\n    \"src\": \"/blog/static/559ceecae597e1c577b0583d8327a388/bbe0c/testing.jpg\",\n    \"srcSet\": [\"/blog/static/559ceecae597e1c577b0583d8327a388/46946/testing.jpg 240w\", \"/blog/static/559ceecae597e1c577b0583d8327a388/55489/testing.jpg 480w\", \"/blog/static/559ceecae597e1c577b0583d8327a388/bbe0c/testing.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Girl with red hat\",\n    url: \"https://unsplash.com/@girlwithredhat\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"Questions around the testing topic come up quite often together with React Query, so I'll try to answer some of them here. I think one reason for that is that testing \\\"smart\\\" components (also called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"container components\"), \") is not the easiest thing to do. With the rise of hooks, this split has been largely deprecated. It is now encouraged to consume hooks directly where you need them rather than doing a mostly arbitrary split and drill props down.\"), mdx(\"p\", null, \"I think this is generally a very good improvement for colocation and code readability, but we now have more components that consume dependencies outside of \\\"just props\\\".\"), mdx(\"p\", null, \"They might \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useContext\"), \". They might \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useSelector\"), \". Or they might \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \".\"), mdx(\"p\", null, \"Those components are technically no longer pure, because calling them in different environments leads to different results. When testing them, you need to carefully setup those surrounding environments to get things working.\"), mdx(\"h2\", {\n    \"id\": \"mocking-network-requests\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Mocking network requests\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#mocking-network-requests\",\n    \"aria-label\": \"mocking network requests permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Since React Query is an async server state management library, your components will likely make requests to a backend. When testing, this backend is not available to actually deliver data, and even if, you likely don't want to make your tests dependent on that.\"), mdx(\"p\", null, \"There are tons of articles out there on how to mock data with jest. You can mock your api client if you have one. You can mock fetch or axios directly. I can only second what Kent C. Dodds has written in his article \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kentcdodds.com/blog/stop-mocking-fetch\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Stop mocking fetch\"), \":\"), mdx(\"p\", null, \"Use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://mswjs.io/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"mock service worker\"), \" by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/ApiMocking\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"@ApiMocking\")), mdx(\"p\", null, \"It can be your single source of truth when it comes to mocking your apis:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"works in node for testing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"supports REST and GraphQL\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"has a \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://storybook.js.org/addons/msw-storybook-addon\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"storybook addon\"), \" so you can write stories for your components that \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"useQuery\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"works in the browser for development purposes, and you'll still see the requests going out in the browser devtools\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"works with cypress, similar to fixtures\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"With our network layer being taken care of, we can start talking about React Query specific things to keep an eye on:\"), mdx(\"h2\", {\n    \"id\": \"queryclientprovider\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"QueryClientProvider\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#queryclientprovider\",\n    \"aria-label\": \"queryclientprovider permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Whenever you use React Query, you need a QueryClientProvider and give it a queryClient - a vessel which holds the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryCache\"), \". The cache will in turn hold the data of your queries.\"), mdx(\"p\", null, \"I prefer to give each test its own QueryClientProvider and create a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"new QueryClient\"), \" for each test. That way, tests are completely isolated from each other. A different approach might be to clear the cache after each test, but I like to keep shared state between tests as minimal as possible. Otherwise, you might get unexpected and flaky results if you run your tests in parallel.\"), mdx(\"h3\", {\n    \"id\": \"for-custom-hooks\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"For custom hooks\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#for-custom-hooks\",\n    \"aria-label\": \"for custom hooks permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"If you are testing custom hooks, I'm quite certain you're using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-hooks-testing-library.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"react-hooks-testing-library\"), \". It's the easiest thing there is to test hooks. With that library, we can wrap our hook in a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-hooks-testing-library.com/reference/api#wrapper\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"wrapper\"), \", which is a React component to wrap the test component in when rendering. I think this is the perfect place to create the QueryClient, because it will be executed once per test:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=wrapper\"\n  }, \"const createWrapper = () => {\\n  // \\u2705 creates a new QueryClient for each test\\n  const queryClient = new QueryClient()\\n  return ({ children }) => (\\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\\n  )\\n}\\n\\ntest(\\\"my first test\\\", async () => {\\n  const { result } = renderHook(() => useCustomHook(), {\\n    wrapper: createWrapper()\\n  })\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"for-components\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"For components\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#for-components\",\n    \"aria-label\": \"for components permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"If you want to test a Component that uses a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" hook, you also need to wrap that Component in QueryClientProvider. A small wrapper around \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"render\"), \" from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://testing-library.com/docs/react-testing-library/intro/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"react-testing-library\"), \" seems like a good choice. Have a look at how React Query does it \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/blob/ead2e5dd5237f3d004b66316b5f36af718286d2d/src/react/tests/utils.tsx#L6-L17\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"internally for their tests\"), \".\"), mdx(\"h2\", {\n    \"id\": \"turn-off-retries\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Turn off retries\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#turn-off-retries\",\n    \"aria-label\": \"turn off retries permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"It's one of the most common \\\"gotchas\\\" with React Query and testing: The library defaults to three retries with exponential backoff, which means that your tests are likely to timeout if you want to test an erroneous query. The easiest way to turn retries off is, again, via the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryClientProvider\"), \". Let's extend the above example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=no-retries\",\n    \"metastring\": \"{2-9}\",\n    \"{2-9}\": true\n  }, \"const createWrapper = () => {\\n  const queryClient = new QueryClient({\\n    defaultOptions: {\\n      queries: {\\n        // \\u2705 turns retries off\\n        retry: false,\\n      },\\n    },\\n  })\\n\\n  return ({ children }) => (\\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\\n  )\\n}\\n\\ntest(\\\"my first test\\\", async () => {\\n  const { result } = renderHook(() => useCustomHook(), {\\n    wrapper: createWrapper()\\n  })\\n}\\n\")), mdx(\"p\", null, \"This will set the defaults for all queries in the component tree to \\\"no retries\\\". It is important to know that this will only work if your actual \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" has no explicit retries set. If you have a query that wants 5 retries, this will still take precedence, because defaults are only taken as a fallback.\"), mdx(\"h3\", {\n    \"id\": \"setquerydefaults\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"setQueryDefaults\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#setquerydefaults\",\n    \"aria-label\": \"setquerydefaults permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The best advice I can give you for this problem is: Don't set these options on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" directly. Try to use and override the defaults as much as possible, and if you really need to change something for specific queries, use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"queryClient.setQueryDefaults\"), \".\"), mdx(\"p\", null, \"So for example, instead of setting retry on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=not-on-useQuery\"\n  }, \"const queryClient = new QueryClient()\\n\\nfunction App() {\\n  return (\\n    <QueryClientProvider client={queryClient}>\\n      <Example />\\n    </QueryClientProvider>\\n  )\\n}\\n\\nfunction Example() {\\n  // \\uD83D\\uDEA8 you cannot override this setting for tests!\\n  const queryInfo = useQuery('todos', fetchTodos, { retry: 5 })\\n}\\n\")), mdx(\"p\", null, \"Set it like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=setQueryDefaults\",\n    \"metastring\": \"{9-10}\",\n    \"{9-10}\": true\n  }, \"const queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      retry: 2,\\n    },\\n  },\\n})\\n\\n// \\u2705 only todos will retry 5 times\\nqueryClient.setQueryDefaults('todos', { retry: 5 })\\n\\nfunction App() {\\n  return (\\n    <QueryClientProvider client={queryClient}>\\n      <Example />\\n    </QueryClientProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Here, all queries will retry two times, only \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"todos\"), \" will retry five times, and I still have the option to turn it off for all queries in my tests \\uD83D\\uDE4C.\"), mdx(\"h3\", {\n    \"id\": \"reactqueryconfigprovider\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"ReactQueryConfigProvider\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#reactqueryconfigprovider\",\n    \"aria-label\": \"reactqueryconfigprovider permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Of course, this only works for known query keys. Sometimes, you really want to set some configs on a subset of your component tree. In v2, React Query had a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query-v2.tanstack.com/docs/api#reactqueryconfigprovider\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"ReactQueryConfigProvider\"), \" for that exact use-case. You can achieve the same thing in v3 with a couple of lines of codes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=ReactQueryConfigProvider\"\n  }, \"const ReactQueryConfigProvider = ({ children, defaultOptions }) => {\\n  const client = useQueryClient()\\n  const [newClient] = React.useState(\\n    () =>\\n      new QueryClient({\\n        queryCache: client.getQueryCache(),\\n        muationCache: client.getMutationCache(),\\n        defaultOptions,\\n      })\\n  )\\n\\n  return (\\n    <QueryClientProvider client={newClient}>{children}</QueryClientProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"You can see this in action in this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/react-query-config-provider-v3-lt00f\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"codesandbox example\"), \".\"), mdx(\"h2\", {\n    \"id\": \"always-await-the-query\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Always await the query\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#always-await-the-query\",\n    \"aria-label\": \"always await the query permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Since React Query is async by nature, when running the hook, you won't immediately get a result. It usually will be in loading state and without data to check. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-hooks-testing-library.com/reference/api#async-utilities\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"async utilities\"), \" from react-hooks-testing-library offer a lot of ways to solve this problem. For the simplest case, we can just wait until the query has transitioned to success state:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=waitFor\",\n    \"metastring\": \"{19-22}\",\n    \"{19-22}\": true\n  }, \"const createWrapper = () => {\\n  const queryClient = new QueryClient({\\n    defaultOptions: {\\n      queries: {\\n        retry: false,\\n      },\\n    },\\n  })\\n  return ({ children }) => (\\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\\n  )\\n}\\n\\ntest(\\\"my first test\\\", async () => {\\n  const { result, waitFor } = renderHook(() => useCustomHook(), {\\n    wrapper: createWrapper()\\n  })\\n\\n  // \\u2705 wait until the query has transitioned to success state\\n  await waitFor(() => result.current.isSuccess)\\n\\n  expect(result.current.data).toBeDefined()\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"silence-the-error-console\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Silence the error console\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#silence-the-error-console\",\n    \"aria-label\": \"silence the error console permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Per default, React Query prints errors to the console. I think this is quite disturbing during testing, because you'll see \\uD83D\\uDD34 in the console even though all tests are \\uD83D\\uDFE2. React Query allows overwriting that default behaviour by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/setLogger\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"setting a logger\"), \", so that's what I'm usually doing:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=silence-errors\"\n  }, \"import { setLogger } from 'react-query'\\n\\nsetLogger({\\n  log: console.log,\\n  warn: console.warn,\\n  // \\u2705 no more errors on the console\\n  error: () => {},\\n})\\n\")), mdx(\"h2\", {\n    \"id\": \"putting-it-all-together\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Putting it all together\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#putting-it-all-together\",\n    \"aria-label\": \"putting it all together permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I've setup a quick repository where all of this comes nicely together: mock-service-worker, react-testing-library and the mentioned wrapper. It contains four tests - basic failure and success tests for custom hooks and components. Have a look here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/TkDodo/testing-react-query\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"https://github.com/TkDodo/testing-react-query\")), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #…","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/559ceecae597e1c577b0583d8327a388/a6c62/testing.jpg"}}}}},"pageContext":{"slug":"/testing-react-query","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}