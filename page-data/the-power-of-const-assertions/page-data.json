{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/the-power-of-const-assertions",
    "result": {"data":{"post":{"slug":"/the-power-of-const-assertions","title":"The power of const assertions","date":"08.10.2020","tags":[{"name":"TypeScript","slug":"type-script"}],"description":"const assertions are a criminally underused TypeScript feature - learn all about them here, now","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The power of const assertions\",\n  \"description\": \"const assertions are a criminally underused TypeScript feature - learn all about them here, now\",\n  \"date\": \"2020-10-08T00:00:00.000Z\",\n  \"banner\": \"./power.jpg\",\n  \"tags\": [\"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABAAB/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQAC/9oADAMBAAIQAxAAAAEOB3SiNF//xAAZEAACAwEAAAAAAAAAAAAAAAAAAgEDEhP/2gAIAQEAAQUCislTJpjo5tj/xAAXEQEAAwAAAAAAAAAAAAAAAAAAAREh/9oACAEDAQE/AYpj/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAECEf/aAAgBAgEBPwF0zT//xAAYEAADAQEAAAAAAAAAAAAAAAAAATEyEP/aAAgBAQAGPwInKzTNM//EABkQAAIDAQAAAAAAAAAAAAAAAAABESHxUf/aAAgBAQABPyF0WjkJO4No0DQP/9oADAMBAAIAAwAAABBU3//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8QmtKP/8QAFxEBAAMAAAAAAAAAAAAAAAAAAAERMf/aAAgBAgEBPxCVi7//xAAbEAEAAwEAAwAAAAAAAAAAAAABACExEVFhkf/aAAgBAQABPxBQoO7F5Z47MxI+oEUUVBWZaA59c//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"power\",\n    \"title\": \"power\",\n    \"src\": \"/blog/static/150ce318fef23eadb0b544bd95cd93f5/bbe0c/power.jpg\",\n    \"srcSet\": [\"/blog/static/150ce318fef23eadb0b544bd95cd93f5/46946/power.jpg 240w\", \"/blog/static/150ce318fef23eadb0b544bd95cd93f5/55489/power.jpg 480w\", \"/blog/static/150ce318fef23eadb0b544bd95cd93f5/bbe0c/power.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Jack B\",\n    url: \"https://unsplash.com/@nervum\",\n    mdxType: \"Attribution\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"const assertions\"), \"\\nwere introduced in TypeScript 3.4 (March 2019), so they are not exactly new,\\nyet I have seen that many developers are still unaware of that feature.\"), mdx(\"p\", null, \"Maybe it's the syntax that makes it a bit weird sometimes (writing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const something = ... as const\"), \").\\nIt might also be it's the resemblance to type assertions that make people afraid of using them.\\nOr possibly, you just got some weird errors regarding \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"readonly\"), \", so you decided to not dig deeper.\"), mdx(\"p\", null, \"In this article, I'd like to clear up the confusion and crush all doubts about const assertions.\"), mdx(\"h2\", {\n    \"id\": \"const-assertions-are-not-type-assertions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"const assertions are \", mdx(\"em\", {\n    parentName: \"h2\"\n  }, \"not\"), \" type assertions\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#const-assertions-are-not-type-assertions\",\n    \"aria-label\": \"const assertions are not type assertions permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Type assertions are, simply put, evil.\\nThey are meant to tell the compiler: \\\"I know what I am doing, and I know it better than you\\\".\"), mdx(\"p\", null, \"Frankly, most of the time, developers \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"do not\"), \" know better than the compiler.\\nSo unless there is a really good reason, do not use type assertions.\"), mdx(\"p\", null, \"Here are some examples of what type assertions allow you to do:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=type-assertions\"\n  }, \"type Foo = 'foo'\\nconst foo = 'bar' as Foo\\n\\ntype Obj = { foo: Foo }\\nconst obj = {} as Obj\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAYg9nKBeKByAZg1BYAUAYzgDsBnYKTRFVAIwEMAnVKOk2BPPUSKAeRoBWyKAG8KCAFztEAXzyFS5OIOEiZLNvwF4gA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"TypeScript is fine with that, because the types sufficiently overlap (string with 'foo' and object with Obj).\\nOf course, that is just false, but by using type assertions, the compiler will yield to you.\"), mdx(\"p\", null, \"This can be troublesome, even in cases where you think you are right. Consider the following example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=strings-inferred\"\n  }, \"type Variant = 'primary' | 'secondary'\\n\\ntype Props = {\\n  variant: Variant\\n}\\n\\nconst Component = (props: Props) => void 0\\n\\nconst props = { variant: 'primary' }\\n\\nComponent(props)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUJqc7IbGpuhWAkIOQA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"Here, the compiler will complain with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Argument of type '{ variant: string; }' is not assignable to parameter of type 'Props'.\\n  Types of property 'variant' are incompatible.\\n    Type 'string' is not assignable to type 'Variant'.(2345)\\n\")), mdx(\"p\", null, \"because variant will be inferred to string.\\nTypeScript is doing this because nothing stops you from re-assigning another string to variant:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=re-assign-object-properties\",\n    \"metastring\": \"{10}\",\n    \"{10}\": true\n  }, \"type Variant = 'primary' | 'secondary'\\n\\ntype Props = {\\n  variant: Variant\\n}\\n\\nconst Component = (props: Props) => void 0\\n\\nconst props = { variant: 'primary' }\\nprops.variant = 'somethingElse'\\n\\nComponent(props)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUJrsQZQAdLLIqiI4lEYQwAAWSKgA5gCiADbUbJzshsam6FYCQg5AA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"Even though we define a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"const\"), \", objects in JavaScript are still mutable, so inferring the string literal 'primary' would be wrong.\\nA type assertion would solve this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=type-asserting-props\",\n    \"metastring\": \"{9}\",\n    \"{9}\": true\n  }, \"type Variant = 'primary' | 'secondary'\\n\\ntype Props = {\\n  variant: Variant\\n}\\n\\nconst Component = (props: Props) => void 0\\n\\nconst props = { variant: 'primary' } as Props\\n\\nComponent(props)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUOpQcML2Qr6GxqboVgJCDkA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"All good - except, it isn't.\\nFor the same reasons I mentioned earlier, if we remove primary from our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Variant\"), \" type, we will not get a type error here.\\nThis means that, like many solutions, this is something that works now, but is not very future proof.\"), mdx(\"p\", null, \"Making your software resilient to change is, in my opinion, one of the true benefits of using TypeScript.\\nAchieving resilience requires the right mindset, which includes abandoning type assertions.\"), mdx(\"p\", null, \"For this scenario, the easiest solution (assuming that inlining the object is not an option)\\nwould be to use an explicit type annotation rather than a type assertion:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=annotating-props\",\n    \"metastring\": \"{9}\",\n    \"{9}\": true\n  }, \"type Variant = 'primary' | 'secondary'\\n\\ntype Props = {\\n  variant: Variant\\n}\\n\\nconst Component = (props: Props) => void 0\\n\\nconst props: Props = { variant: 'primary' }\\n\\nComponent(props)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQnYCQiKiMiqKuPhIRAgkUJqc7IbGpuhWoZQOQA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"This is likely what most of you are doing right now, and it is perfectly fine regarding type-safety.\"), mdx(\"h2\", {\n    \"id\": \"using-const-assertions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Using const assertions\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#using-const-assertions\",\n    \"aria-label\": \"using const assertions permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I still think that fixing the issue with const assertions is the preferred way of doing it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=const-assertions\",\n    \"metastring\": \"{9}\",\n    \"{9}\": true\n  }, \"type Variant = 'primary' | 'secondary'\\n\\ntype Props = {\\n  variant: Variant\\n}\\n\\nconst Component = (props: Props) => void 0\\n\\nconst props = { variant: 'primary' } as const\\n\\nComponent(props)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWACgPRIoAFBOmEpYoAbw5RJUAG6IU6AFyw5aYBwC+HDvVSUMAYToEwDCOhEAKfIMpL+NgJRYAfDLpJGUAAxb2OvVDWQiKiMiqKuPhIRAgkUOpQcML+apzshsam6FYCQg5AA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"This comes in handy if you don't have the type available for annotation, for example, because it has not been exported from a library you are using.\\nThe syntax is also more terse, and using const assertions has other benefits as well.\\nBecause you are signalling TypeScript that your object is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"really\"), \" constant, the compiler can make better assumptions about your intentions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"strings and numbers can be inferred as their literal counterparts\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"arrays become tuples with a fixed length\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"everything is readonly, so you cannot accidentally mutate it afterwards (looking at you, \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Array.sort\"), \")\")), mdx(\"p\", null, \"This will give you a ton of flexibility when working with that constant on type level.\"), mdx(\"h2\", {\n    \"id\": \"extracting-types-from-objects-or-arrays\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Extracting Types from Objects or Arrays\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#extracting-types-from-objects-or-arrays\",\n    \"aria-label\": \"extracting types from objects or arrays permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Consider the following example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=constant-options-array\"\n  }, \"type Variant = 'primary' | 'secondary'\\ntype Option = { id: Variant; label: string }\\n\\nconst options: Array<Option> = [\\n  {\\n    id: 'primary',\\n    label: 'The primary option',\\n  },\\n  {\\n    id: 'secondary',\\n    label: 'The seondary option',\\n  },\\n]\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAaghgJwJZwHbCgXigcjMgW0RBygB9cBnCAYwHtUATYnAWAChRIoB5MYJAyxQA3lCSMAXLEQp0AbigAbOACMIS6ZWDJUAcygBfDh3qptUOv0HnpAQQQI4IADx8BDAHzCA2hygBov6BIRLSeIQsADTBIQEq6pq4ACoAFtD4SEQIIJbWDDgx7CGGRSEisXFhVLQMzDmFlSEJGuFp0NR1xHkeqI3FgaUcALpAA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"So far, so easy. If we want to add another variant, we just have to add it to the Variant type \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" to the options Array.\\nThis is fine as long as the code is co-located, and because we have explicitly annotated the options Array,\\nbut it can also become quite boilerplate-y pretty fast.\\nWith const assertions, you can just grab the type from the options Array:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=extract-it\"\n  }, \"const options = [\\n  {\\n    id: 'primary',\\n    label: 'The primary option',\\n  },\\n  {\\n    id: 'secondary',\\n    label: 'The seondary option',\\n  },\\n] as const\\n\\ntype Variant = typeof options[number]['id']\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/MYewdgzgLgBCAOUCW4IwLwwNoFgBQMhMA3vkeTEgCYBcMA5PAE5IC2AhkwJ70A0ZFQgBt2AIwCmQuvQAqAC3ExmbTlziIUYPgMIBffgSKlDg6tIjjQYKqu0mKIiVIbzFF8De7rk4O+X34ALow7GhW0Pj4UFzwigBqnEjsYLCY0bEgAGbemhBYYACurBJMgVj01PSBQA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"We are basically telling the compiler: Walk through every item of options and give me the type of the id.\\nMuch terser syntax, the type will still be correctly inferred to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"primary | secondary\"), \", and we now have one single source of truth.\"), mdx(\"p\", null, \"Of course, this only works because of the const assertion, and if you remove it or forget it, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Variant\"), \" will just be of type number.\\nThis is a problem because it relies on developers not making mistakes, and if we wanted to rely on that, we could also just write JavaScript.\"), mdx(\"p\", null, \"Luckily, we can also tell the compiler to only make this work with readonly Arrays:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=ensure-readonly\",\n    \"metastring\": \"{12-22}\",\n    \"{12-22}\": true\n  }, \"const options = [\\n  {\\n    id: 'primary',\\n    label: 'The primary option',\\n  },\\n  {\\n    id: 'secondary',\\n    label: 'The seondary option',\\n  },\\n] as const\\n\\ntype EnsureReadonlyArray<T> = T extends Array<any>\\n  ? never\\n  : T extends ReadonlyArray<any>\\n  ? T\\n  : never\\nexport type ExtractValue<\\n  T extends ReadonlyArray<any>,\\n  K extends keyof T[number]\\n> = EnsureReadonlyArray<T>[number][K]\\n\\ntype Variant = ExtractValue<typeof options, 'id'>\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/MYewdgzgLgBCAOUCW4IwLwwNoFgBQMhMA3vkeTEgCYBcMA5PAE5IC2AhkwJ70A0ZFQgBt2AIwCmQuvQAqAC3ExmbTlziIUYPgMIBffgSKlDg6tIjjQYKqu0mKIiVIbzFF8De7rk4O+X34ALow7GhW0Pj4UFzwigCikACuTOIASuLsVOBCXACCTEzsXAA8MgB8GDAyMOIAHlDi1mj5hSXsYFxlOjAA-DBg4gBu4kzddNV1DU0w6ZnZeQVFxe2d3X0yY-1DI-h18CBMsNGxMHH1hcBQAGrsQonixd0T9Y1UaLNZYDktSytlBuQANI1F7TADW4i4IAAZlUsGBEqwJExAvgKpgEhBkmkMp9vosSuV4YjkYEsIDUXgojFFDcWO1YBjzuxLjc7g9juIYd5NBBeAxqPQykA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"This is admittedly a bit hackish, as it relies on the fact that const assertions make everything readonly.\\nBut it will make sure that Variant is inferred to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"never\"), \" if you forget the const assertion, and that means you won't be able to use it anywhere.\\nI'll take that safety any day (and tuck \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ExtractValue\"), \" away in a util).\"), mdx(\"h2\", {\n    \"id\": \"use-readonly-everywhere\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Use readonly everywhere\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#use-readonly-everywhere\",\n    \"aria-label\": \"use readonly everywhere permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Finally, I'd like to point out something that became more apparent to me since I am constantly using const assertions:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Make everything readonly per default\")), mdx(\"p\", {\n    style: {\n      \"paddingLeft\": \"3rem\",\n      \"marginTop\": \"-1rem\"\n    }\n  }, \"\\u2014 TkDodo\"), mdx(\"p\", null, \"The thing is: You \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can\"), \" pass a mutable Array or Object into a method that takes a readonly Array or Object, but \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" the other way around.\\nThe reason is quite simple: if my function accepts an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Array\"), \", the function might mutate it, so you cannot pass a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ReadonlyArray\"), \" to it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=prefer-readonly\"\n  }, \"const getFirst = (param: Array<string>): string => param.sort()[0]\\n\\nconst strings = ['foo', 'bar', 'baz'] as const\\n\\ngetFirst(strings)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/MYewdgzgLgBA5gUygMQJYCdowLwwBQAOAhukQLYBcMAguqQJ4A806qYcAfAJRUttw4OMYqTIA6CCHRQ8XANoAGALoBYAFDrQkWH3YQcMOQHIAZiBBGANDCMAjElZv2AXkaUwi+rdHXrEKDGg8XTgILiA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"Even if you wouldn't sort the Array, it would still error with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Argument of type 'readonly [\\\"foo\\\", \\\"bar\\\", \\\"baz\\\"]' is not assignable to parameter of type 'string[]'.\\n  The type 'readonly [\\\"foo\\\", \\\"bar\\\", \\\"baz\\\"]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.(2345)\\n\")), mdx(\"p\", null, \"By making the parameter readonly, we just guarantee that we are not mutating it (which is always good - don't mess with function parameters)\\nand we make people's lives easier if they are using const assertions in the process.\"), mdx(\"p\", null, \"If you are a library author, I strongly recommend making all inputs to your functions readonly.\"), mdx(Comments, {\n    mdxType: \"Comments\"\n  }, \"Do you also prefer const assertions? Leave a comment below \\u2B07\\uFE0F\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"const assertions \nwere introduced in TypeScript 3.4 (March 2019), so they are not exactly new,\nyet I have seen that many developers areâ€¦","timeToRead":3,"banner":{"childImageSharp":{"resize":{"src":"/static/150ce318fef23eadb0b544bd95cd93f5/a6c62/power.jpg"}}}}},"pageContext":{"slug":"/the-power-of-const-assertions","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}