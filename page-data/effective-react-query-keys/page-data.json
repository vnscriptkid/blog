{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/effective-react-query-keys",
    "result": {"data":{"post":{"slug":"/effective-react-query-keys","title":"Effective React Query Keys","date":"13.06.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"Learn how to structure React Query Keys effectively as your App grows","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Effective React Query Keys\",\n  \"description\": \"Learn how to structure React Query Keys effectively as your App grows\",\n  \"date\": \"2021-06-13T00:00:00.000Z\",\n  \"banner\": \"./keys.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"62.916666666666664%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMCBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAACAf/aAAwDAQACEAMQAAABzm0WBJJin//EABkQAAMAAwAAAAAAAAAAAAAAAAABAgMSIf/aAAgBAQABBQLEUNdVG5TP/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/ARF//8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/ATV//8QAFhAAAwAAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Alh//8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERIRAx/9oACAEBAAE/IfCcNqvgeitE1SMP/9oADAMBAAIAAwAAABAcH//EABcRAQEBAQAAAAAAAAAAAAAAAAEAETH/2gAIAQMBAT8Q4LIbf//EABYRAQEBAAAAAAAAAAAAAAAAAAABIf/aAAgBAgEBPxCzX//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExUWGhsf/aAAgBAQABPxAGhfYV7hFRLyvka1GTL5PMpBRSQfKiu8vc/9k=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"keys\",\n    \"title\": \"keys\",\n    \"src\": \"/blog/static/bb0cf6c7bce80ebc7c101954b313bf9a/bbe0c/keys.jpg\",\n    \"srcSet\": [\"/blog/static/bb0cf6c7bce80ebc7c101954b313bf9a/46946/keys.jpg 240w\", \"/blog/static/bb0cf6c7bce80ebc7c101954b313bf9a/55489/keys.jpg 480w\", \"/blog/static/bb0cf6c7bce80ebc7c101954b313bf9a/bbe0c/keys.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Chunli Ju\",\n    url: \"https://unsplash.com/@chunlea\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#8: Effective React Query Keys\"), \"- [#8a: Leveraging the Query Function Context](leveraging-the-query-function-context)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/query-keys\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Query Keys\"), \" are a very important core concept in React Query. They are necessary so that the library can internally cache your data correctly and refetch automatically when a dependency to your query changes. Lastly, it will allow you to interact with the Query Cache manually when needed, for example, when updating data after a mutation or when you need to manually invalidate some queries.\"), mdx(\"p\", null, \"Let's quickly have a look at what these three points mean before showing you how I personally organize Query Keys to be able to do these things more effectively.\"), mdx(\"h2\", {\n    \"id\": \"caching-data\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Caching Data\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#caching-data\",\n    \"aria-label\": \"caching data permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Internally, the Query Cache is just a JavaScript object, where the keys are serialized Query Keys and the values are your Query Data plus meta information. The keys are hashed in a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/query-keys#query-keys-are-hashed-deterministically\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"deterministic way\"), \", so you can use objects as well (on the top level, keys have to be strings or arrays though).\"), mdx(\"p\", null, \"The most important part is that keys need to be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unique\"), \" for your queries. If React Query finds an entry for a key in the cache, it will use it. Please also be aware that you cannot use the same key for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useInfiniteQuery\"), \". There is, after all, only \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"one\"), \" Query Cache, and you would share the data between these two. That is not good because infinite queries have a fundamentally different structure than \\\"normal\\\" queries.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=dont-mix-keys\"\n  }, \"useQuery(['todos'], fetchTodos)\\n\\n// \\uD83D\\uDEA8 this won't work\\nuseInfiniteQuery(['todos'], fetchInfiniteTodos)\\n\\n// \\u2705 choose something else instead\\nuseInfiniteQuery(['infiniteTodos'], fetchInfiniteTodos)\\n\")), mdx(\"h2\", {\n    \"id\": \"automatic-refetching\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Automatic Refetching\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#automatic-refetching\",\n    \"aria-label\": \"automatic refetching permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Queries are declarative.\")), mdx(\"p\", null, \"This is a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very\"), \" important concept that cannot be emphasized enough, and it's also something that might take some time to \\\"click\\\". Most people think about queries, and especially refetching, in an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"imperative\"), \" way.\"), mdx(\"p\", null, \"I have a query, it fetches some data. Now I click this button and I want to refetch, but with different parameters. I've seen many attempts that look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=imperative-refetch\"\n  }, \"function Component() {\\n  const { data, refetch } = useQuery(['todos'], fetchTodos)\\n\\n  // \\u2753 how do I pass parameters to refetch \\u2753\\n  return <Filters onApply={() => refetch(???)} />\\n}\\n\")), mdx(\"p\", null, \"The answer is: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"You don't.\")), mdx(\"p\", null, \"That's not what \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetch\"), \" is for - it's for refetching \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"with the same parameters\"), \".\"), mdx(\"p\", null, \"If you have some \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"state\"), \" that changes your data, all you need to do is to put it in the Query Key, because React Query will trigger a refetch automatically whenever the key changes. So when you want to apply your filters, just change your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"client state\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=query-key-drives-the-query\",\n    \"metastring\": \"{2-3, 5}\",\n    \"{2-3,\": true,\n    \"5}\": true\n  }, \"function Component() {\\n  const [filters, setFilters] = React.useState()\\n  const { data } = useQuery(['todos', filters], () => fetchTodos(filters))\\n\\n  // \\u2705 set local state and let it \\\"drive\\\" the query\\n  return <Filters onApply={setFilters} />\\n}\\n\")), mdx(\"p\", null, \"The re-render triggered by the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setFilters\"), \" update will pass a different Query Key to React Query, which will make it refetch. I have a more in-depth example in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"practical-react-query#treat-the-query-key-like-a-dependency-array\"\n  }, \"#1: Practical React Query - Treat the query key like a dependency array\"), \".\"), mdx(\"h2\", {\n    \"id\": \"manual-interaction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Manual Interaction\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#manual-interaction\",\n    \"aria-label\": \"manual interaction permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Manual Interactions with the Query Cache are where the structure of your Query Keys is most important. Many of those interaction methods, like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/QueryClient#queryclientinvalidatequeries\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"invalidateQueries\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/QueryClient#queryclientsetqueriesdata\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"setQueriesData\"), \" support \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/filters#query-filters\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Query Filters\"), \", which allow you to fuzzily match your Query Keys.\"), mdx(\"h2\", {\n    \"id\": \"effective-react-query-keys\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Effective React Query Keys\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#effective-react-query-keys\",\n    \"aria-label\": \"effective react query keys permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Please note that these points reflect my personal opinion (as everything on this blog, actually), so don't take it as something that you absolutely must do when working with Query Keys. I have found these strategies to work best when your App becomes more complex, and they also scale quite well. You definitely don't need to do this for a Todo App \\uD83D\\uDE01.\"), mdx(\"h3\", {\n    \"id\": \"colocate\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Colocate\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#colocate\",\n    \"aria-label\": \"colocate permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"If you haven't yet read \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kentcdodds.com/blog/colocation\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Maintainability through colocation\"), \" by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/kentcdodds\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Kent C. Dodds\"), \", please do. I don't believe that storing all your Query Keys globally in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/src/utils/queryKeys.ts\"), \" will make things better. I keep my Query Keys next to their respective queries, co-located in a feature directory, so something like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n- src\\n  - features\\n    - Profile\\n      - index.tsx\\n      - queries.ts\\n    - Todos\\n      - index.tsx\\n      - queries.ts\\n\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queries\"), \" file will contain everything React Query related. I usually only export custom hooks, so the actual Query Functions as well as Query Keys will stay local.\"), mdx(\"h3\", {\n    \"id\": \"always-use-array-keys\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Always use Array Keys\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#always-use-array-keys\",\n    \"aria-label\": \"always use array keys permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Yes, Query Keys can be a string, too, but to keep things unified, I like to always use Arrays. React Query will internally convert them to an Array anyhow, so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=always-use-array-keys\"\n  }, \"// \\uD83D\\uDEA8 will be transformed to ['todos'] anyhow\\nuseQuery('todos')\\n// \\u2705\\nuseQuery(['todos'])\\n\")), mdx(\"h3\", {\n    \"id\": \"structure\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Structure\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#structure\",\n    \"aria-label\": \"structure permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Structure your Query Keys from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"most generic\"), \" to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"most specific\"), \", with as many levels of granularity as you see fit in between. Here's how I would structure a todos list that allows for filterable lists as well as detail views:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"['todos', 'list', { filters: 'all' }]\\n['todos', 'list', { filters: 'done' }]\\n['todos', 'detail', 1]\\n['todos', 'detail', 2]\\n\")), mdx(\"p\", null, \"With that structure, I can invalidate everything todo related with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"['todos']\"), \", all the lists or all the details, as well as target one specific list if I know the exact key. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/updates-from-mutation-responses\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Updates from Mutation Responses\\n\"), \" become a lot more flexible with this, because you can target all lists if necessary:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=updates-from-mutation-responses\"\n  }, \"function useUpdateTitle() {\\n  return useMutation(updateTitle, {\\n    onSuccess: (newTodo) => {\\n      // \\u2705 update the todo detail\\n      queryClient.setQueryData(['todos', 'detail', newTodo.id], newTodo)\\n\\n      // \\u2705 update all the lists that contain this todo\\n      queryClient.setQueriesData(['todos', 'list'], (previous) =>\\n        previous.map((todo) => (todo.id === newTodo.id ? newtodo : todo))\\n      )\\n    },\\n  })\\n}\\n\")), mdx(\"p\", null, \"This might not work if the structure of lists and details differ a lot, so alternatively, you can also of course just invalidate all the lists instead:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=invalidate-all-lists\",\n    \"metastring\": \"{6-7}\",\n    \"{6-7}\": true\n  }, \"function useUpdateTitle() {\\n  return useMutation(updateTitle, {\\n    onSuccess: (newTodo) => {\\n      queryClient.setQueryData(['todos', 'detail', newTodo.id], newTodo)\\n\\n      // \\u2705 just invalidate all the lists\\n      queryClient.invalidateQueries(['todos', 'list'])\\n    },\\n  })\\n}\\n\")), mdx(\"p\", null, \"If you know which list you are currently on, e.g. by reading the filters from the url, and can therefore construct the exact Query Key, you can also combine this two methods and call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setQueryData\"), \" on your list and invalidate all the others:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=combine\",\n    \"metastring\": \"{10-19}\",\n    \"{10-19}\": true\n  }, \"function useUpdateTitle() {\\n  // imagine a custom hook that returns the current filters,\\n  // stored in the url\\n  const { filters } = useFilterParams()\\n\\n  return useMutation(updateTitle, {\\n    onSuccess: (newTodo) => {\\n      queryClient.setQueryData(['todos', 'detail', newTodo.id], newTodo)\\n\\n      // \\u2705 update the list we are currently on instantly\\n      queryClient.setQueryData(['todos', 'list', { filters }], (previous) =>\\n        previous.map((todo) => (todo.id === newTodo.id ? newtodo : todo))\\n      )\\n\\n      // \\uD83E\\uDD73 invalidate all the lists, but don't refetch the active one\\n      queryClient.invalidateQueries({\\n        queryKey: ['todos', 'list'],\\n        refetchActive: false,\\n      })\\n    },\\n  })\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"use-query-key-factories\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Use Query Key factories\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#use-query-key-factories\",\n    \"aria-label\": \"use query key factories permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"In the examples above, you can see that I've been manually declaring the Query Keys a lot. This is not only error-prone, but it also makes changes harder in the future, for example, if you find out that you'd like to add \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"another\"), \" level of granularity to your keys.\"), mdx(\"p\", null, \"That's why I recommend one Query Key factory per feature. It's just a simple object with entries and functions that will produce query keys, which you can then use in your custom hooks. For the above example structure, it would look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=query-key-factory\"\n  }, \"const todoKeys = {\\n  all: ['todos'] as const,\\n  lists: () => [...todoKeys.all, 'list'] as const,\\n  list: (filters: string) => [...todoKeys.lists(), { filters }] as const,\\n  details: () => [...todoKeys.all, 'detail'] as const,\\n  detail: (id: number) => [...todoKeys.details(), id] as const,\\n}\\n\")), mdx(\"p\", null, \"This gives me a lot of flexibility, as each level builds on top of another, but is still independently accessible:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=examples\"\n  }, \"// \\uD83D\\uDD7A remove everything related to the todos feature\\nqueryClient.removeQueries(todoKeys.all)\\n\\n// \\uD83D\\uDE80 invalidate all the lists\\nqueryClient.invalidateQueries(todoKeys.lists())\\n\\n// \\uD83D\\uDE4C prefetch a single todo\\nqueryClient.prefetchQueries(todoKeys.detail(id), () => fetchTodo(id))\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #â€¦","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/bb0cf6c7bce80ebc7c101954b313bf9a/a6c62/keys.jpg"}}}}},"pageContext":{"slug":"/effective-react-query-keys","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}