{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/using-web-sockets-with-react-query",
    "result": {"data":{"post":{"slug":"/using-web-sockets-with-react-query","title":"Using WebSockets with React Query","date":"06.06.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"A step-by-step guide on how to make real-time notifications work with react-query","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using WebSockets with React Query\",\n  \"description\": \"A step-by-step guide on how to make real-time notifications work with react-query\",\n  \"date\": \"2021-06-06T00:00:00.000Z\",\n  \"banner\": \"./react-query-websockets.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHChWFLA//EABcQAQEBAQAAAAAAAAAAAAAAAAEAERD/2gAIAQEAAQUCMk6M5f/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAABICH/2gAIAQEABj8ClYf/xAAcEAABBAMBAAAAAAAAAAAAAAAAATFBURARIXH/2gAIAQEAAT8hQrjGny8wCGoWf//aAAwDAQACAAMAAAAQe9//xAAWEQEBAQAAAAAAAAAAAAAAAAAAETH/2gAIAQMBAT8Q1H//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEAAgMBAAAAAAAAAAAAAAABACExQVER/9oACAEBAAE/EEdnViXzoMTyDEMBGr1CCQUr0z//2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"react query websockets\",\n    \"title\": \"react query websockets\",\n    \"src\": \"/blog/static/2bedcabee00a030b6f61274741777e3b/bbe0c/react-query-websockets.jpg\",\n    \"srcSet\": [\"/blog/static/2bedcabee00a030b6f61274741777e3b/46946/react-query-websockets.jpg 240w\", \"/blog/static/2bedcabee00a030b6f61274741777e3b/55489/react-query-websockets.jpg 480w\", \"/blog/static/2bedcabee00a030b6f61274741777e3b/bbe0c/react-query-websockets.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Maxim Hopman\",\n    url: \"https://unsplash.com/@nampoh\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, \"How to handle live data using WebSockets together with React Query has been one of the most asked questions lately, so I thought I'd give it a try, play around with it a bit and report my findings. That's what this post is about :)\"), mdx(\"h2\", {\n    \"id\": \"what-are-websockets\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"What are WebSockets\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-are-websockets\",\n    \"aria-label\": \"what are websockets permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Simply put, WebSockets allow push messages, or \\\"live data\\\", to be sent from the server to the client (browser). Usually with HTTP, the client makes a request to the server, specifying that they would like some data please, the server responds with that data or an error and then the connection closes.\"), mdx(\"p\", null, \"Since the client is the one opening the connections and initiating the requests, that leaves no room for the server to push data to the client when the server knows that an update is available.\"), mdx(\"p\", null, \"That's where \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/WebSocket\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"WebSockets\"), \" kick in.\"), mdx(\"p\", null, \"Like with any other HTTP request, the browser initiates the connection, but indicates that they would like to upgrade the connection to a WebSocket. If the server accepts this, they will then switch the protocol. This connection will not terminate, but will stay open until either side decides to close it. Now, we have a fully functioning bi-directional connection open, where both sides can transmit data.\"), mdx(\"p\", null, \"This has the main advantage that the server can now push selective updates to the client. This can come in very handy if you have multiple users viewing the same data, and one user makes an update. Usually, the other clients will not see that update until they actively refetch. WebSockets allow to instantly push those updates in real-time.\"), mdx(\"h2\", {\n    \"id\": \"react-query-integration\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"React Query integration\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#react-query-integration\",\n    \"aria-label\": \"react query integration permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Since React Query is primarily a client side async state management library, I will \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" talk about how to set up WebSockets on the server. I've honestly never done it, and it also depends on which technology you are using in the backend.\"), mdx(\"p\", null, \"React Query doesn't have anything built-in specifically for WebSockets. That doesn't mean that WebSockets are not supported or that they don't work well with the library. It's just that React Query is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very\"), \" agnostic when it comes to how you fetch your data: All it needs is a resolved or rejected \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" to work - the rest is up to you.\"), mdx(\"h2\", {\n    \"id\": \"step-by-step\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Step by Step\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#step-by-step\",\n    \"aria-label\": \"step by step permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The general idea is to setup your queries as usual, as if you wouldn't be working with WebSockets. Most of the time, you will have your usual HTTP endpoints to query and mutate entities.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=a-standard-query\"\n  }, \"const usePosts = () => useQuery(['posts', 'list'], fetchPosts)\\n\\nconst usePost = (id) =>\\n  useQuery(['posts', 'detail', id], () => fetchPost(id))\\n\")), mdx(\"p\", null, \"Additionally, you can setup an app-wide \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" that connects you to your WebSocket endpoint. How that works totally depends on which technology you are using. I've seen people subscribe to live data from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/issues/171#issuecomment-649810136\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Hasura\"), \". There's a great article about connecting to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://aggelosarvanitakis.medium.com/a-real-time-hook-with-firebase-react-query-f7eb537d5145\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Firebase\"), \". In my example, I will simply use the browser's native \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"WebSocket API\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=useReactQuerySubscription\"\n  }, \"const useReactQuerySubscription = () => {\\n  React.useEffect(() => {\\n    const websocket = new WebSocket('wss://echo.websocket.org/')\\n    websocket.onopen = () => {\\n      console.log('connected')\\n    }\\n\\n    return () => {\\n      websocket.close()\\n    }\\n  }, [])\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"consuming-data\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Consuming data\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#consuming-data\",\n    \"aria-label\": \"consuming data permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"After we've setup the connection, we will likely have some sort of callback that will be called when data comes in over the WebSocket. Again, what that data is depends entirely on how you'd like to set it up. Inspired by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/issues/171#issuecomment-649716718\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"this message\"), \" from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Tanner Linsley\"), \", I like to send \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"events\"), \" from the backend instead of complete data objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=event-based-subscriptions\",\n    \"metastring\": \"{8-12}\",\n    \"{8-12}\": true\n  }, \"const useReactQuerySubscription = () => {\\n  const queryClient = useQueryClient()\\n  React.useEffect(() => {\\n    const websocket = new WebSocket('wss://echo.websocket.org/')\\n    websocket.onopen = () => {\\n      console.log('connected')\\n    }\\n    websocket.onmessage = (event) => {\\n      const data = JSON.parse(event.data)\\n      const queryKey = [...data.entity, data.id].filter(Boolean)\\n      queryClient.invalidateQueries(queryKey)\\n    }\\n\\n    return () => {\\n      websocket.close()\\n    }\\n  }, [queryClient])\\n}\\n\")), mdx(\"p\", null, \"That's really all you need to make list and detail views update when you receive an event.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{ \\\"entity\\\": [\\\"posts\\\", \\\"list\\\"] }\"), \" will invalidate the posts list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{ \\\"entity\\\": [\\\"posts\\\", \\\"detail\\\"], id: 5 }\"), \" will invalidate a single post\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{ \\\"entity\\\": [\\\"posts\\\"] }\"), \" will invalidate everything post related\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/query-invalidation\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Query Invalidation\"), \" plays really nice together with WebSockets. This approach avoids the problem of over pushing, because if we receive an event for an entity that we are not interested in at the moment, nothing will happen. For example, if we are currently on the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Profile\"), \" page, and we receive an update for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Posts\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"invalidateQueries\"), \" will make sure that the next time we get to our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Posts\"), \" page, it will be refetched. However, it will not refetch it right away, because we have no active observers. If we never go to that page again, the pushed update would be completely unnecessary.\"), mdx(\"h3\", {\n    \"id\": \"partial-data-updates\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Partial data updates\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#partial-data-updates\",\n    \"aria-label\": \"partial data updates permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Of course, if you have big data sets that receive small, but frequent updates, you might still want to push partial data down the WebSocket.\"), mdx(\"p\", null, \"Title of the post has changed? Just push the title. Number of likes have changed - push it down.\"), mdx(\"p\", null, \"For these partial updates, you can use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydata\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"queryClient.setQueryData\"), \" to directly update the query cache instead of just invalidating it.\"), mdx(\"p\", null, \"This will be a bit more cumbersome if you have multiple query keys for the same data, e.g. if you have multiple filter criteria as part of the query key, or if you want to update list \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" detail view with the same message. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/QueryClient#queryclientsetqueriesdata\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"queryClient.setQueriesData\"), \" is a relatively new addition to the library that will allow you to tackle this use-case as well:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=partial-updates\",\n    \"metastring\": \"{10-14}\",\n    \"{10-14}\": true\n  }, \"const useReactQuerySubscription = () => {\\n  const queryClient = useQueryClient()\\n  React.useEffect(() => {\\n    const websocket = new WebSocket('wss://echo.websocket.org/')\\n    websocket.onopen = () => {\\n      console.log('connected')\\n    }\\n    websocket.onmessage = (event) => {\\n      const data = JSON.parse(event.data)\\n      queryClient.setQueriesData(data.entity, (oldData) => {\\n        const update = (entity) =>\\n          entity.id === data.id ? { ...entity, ...data.payload } : entity\\n        return Array.isArray(oldData) ? oldData.map(update) : update(oldData)\\n      })\\n    }\\n\\n    return () => {\\n      websocket.close()\\n    }\\n  }, [queryClient])\\n}\\n\")), mdx(\"p\", null, \"It's a bit too dynamic for my taste, doesn't handle addition or deletion, and TypeScript won't like it very much, so I'd personally rather stick to query invalidation.\"), mdx(\"p\", null, \"Nevertheless, here is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/react-query-websockets-ep1op\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"codesandbox example\"), \" where I'm handling both type of events: invalidation and partial updates. (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note: The custom hook is a bit more convoluted because in the example, I use the same WebSocket to simulate the server round trip. Don't worry about it if you have a real server\"), \").\"), mdx(\"h2\", {\n    \"id\": \"increasing-staletime\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Increasing StaleTime\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#increasing-staletime\",\n    \"aria-label\": \"increasing staletime permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"React Query comes with a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/important-defaults\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"default staleTime\"), \" of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"zero\"), \". This means that every query will be immediately considered as stale, which means it will refetch when a new subscriber mounts or when the user refocuses the window. It is aimed to keep your data as up-to-date as necessary.\"), mdx(\"p\", null, \"This goal overlaps a lot with WebSockets, which update your data in real-time. Why would I need to refetch at all if I just manually \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"invalidated\"), \" because the server just told me to do so via a dedicated message?\"), mdx(\"p\", null, \"So if you update all your data via websockets anyways, consider setting a high \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \". In my example, I just used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Infinity\"), \". This means the data will be fetched initially via \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \", and then always come from the cache. Refetching only happens via the explicit query invalidation.\"), mdx(\"p\", null, \"You can best achieve this by setting global query defaults when creating the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryClient\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=infinite-stale-time\"\n  }, \"const queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      staleTime: Infinity,\\n    },\\n  },\\n})\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #…","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/2bedcabee00a030b6f61274741777e3b/a6c62/react-query-websockets.jpg"}}}}},"pageContext":{"slug":"/using-web-sockets-with-react-query","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}