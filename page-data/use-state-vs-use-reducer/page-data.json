{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/use-state-vs-use-reducer",
    "result": {"data":{"post":{"slug":"/use-state-vs-use-reducer","title":"useState vs useReducer","date":"26.09.2021","tags":[{"name":"React","slug":"react"},{"name":"useState pitfalls","slug":"use-state-pitfalls"},{"name":"useState","slug":"use-state"},{"name":"useReducer","slug":"use-reducer"}],"description":"To useState or useReducer, that is the question...","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"useState vs useReducer\",\n  \"description\": \"To useState or useReducer, that is the question...\",\n  \"date\": \"2021-09-26T00:00:00.000Z\",\n  \"banner\": \"./usestate-vs-usereducer.jpeg\",\n  \"tags\": [\"React\", \"useState pitfalls\", \"useState\", \"useReducer\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Divider = makeShortcode(\"Divider\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQP/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAVpg7Dmlz//EABkQAAMBAQEAAAAAAAAAAAAAAAABAhETIf/aAAgBAQABBQJZt+TpNt11bEz/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwEn/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/Aa1//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAERMRIhUf/aAAgBAQAGPwKcWdkpkspGj//EABoQAQACAwEAAAAAAAAAAAAAAAEAESFBYTH/2gAIAQEAAT8hxtTxlQXhKvOHEvRECODErKsE/9oADAMBAAIAAwAAABDj3//EABgRAAIDAAAAAAAAAAAAAAAAAAARASFh/9oACAEDAQE/EEU2LT//xAAXEQEBAQEAAAAAAAAAAAAAAAABABFR/9oACAECAQE/ENKIWeX/xAAdEAEBAAICAwEAAAAAAAAAAAABEQAhMUGRodHB/9oACAEBAAE/EEL8Fsh39wsNjd1Nc++MmAQEoj+YPRSDYHfe3WSQtSWzzloAPAnzP//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"usestate vs usereducer\",\n    \"title\": \"usestate vs usereducer\",\n    \"src\": \"/blog/static/4b9244e41524bf53a06f77265d5061df/bbe0c/usestate-vs-usereducer.jpg\",\n    \"srcSet\": [\"/blog/static/4b9244e41524bf53a06f77265d5061df/46946/usestate-vs-usereducer.jpg 240w\", \"/blog/static/4b9244e41524bf53a06f77265d5061df/55489/usestate-vs-usereducer.jpg 480w\", \"/blog/static/4b9244e41524bf53a06f77265d5061df/bbe0c/usestate-vs-usereducer.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Piret Ilver\",\n    url: \"https://unsplash.com/@saltsup\",\n    mdxType: \"Attribution\"\n  }), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"dont-over-use-state\"\n  }, \"#1: Don't over useState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"putting-props-to-use-state\"\n  }, \"#2: Putting props to useState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"things-to-know-about-use-state\"\n  }, \"#3: Things to know about useState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"use-state-for-one-time-initializations\"\n  }, \"#4: useState for one-time initializations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#5: useState vs. useReducer\"))), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"The question about which state management solution to use might be just as old as React itself (or maybe even older), and answers to it are manifold. To me, there is only one good answer, and it's the same answer I will give to every seemingly complex question:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"It depends.\")), mdx(\"p\", {\n    style: {\n      \"paddingLeft\": \"3rem\",\n      \"marginTop\": \"-1rem\"\n    }\n  }, \"\\u2014 TkDodo\"), mdx(\"p\", null, \"It depends on the type of state. It depends on update frequency. It depends on scoping.\"), mdx(\"p\", null, \"If you know me, you know I have strong preferences on what to do with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"server state\"), \". So lets keep that out of the picture and look at everything that's left:\"), mdx(\"h2\", {\n    \"id\": \"client-state\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Client State\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#client-state\",\n    \"aria-label\": \"client state permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Before hooks, there was only one way of managing client state locally: in class-based components with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"this.setState\"), \". The state had to be an object, and the update function accepted a partial version of it.\"), mdx(\"p\", null, \"Hooks changed that in a fundamental way. Not only could you now also manage state in functional components, you got two different ways of doing so with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useState\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \".\"), mdx(\"p\", null, \"I think the way most people approached the switch from class based state management to hooks was to split up the object and go towards a single \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useState\"), \" for each field:\"), mdx(\"p\", null, \"Before:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=class-based-set-state\"\n  }, \"class Names extends React.Component {\\n  state = {\\n    firstName: '',\\n    lastName: '',\\n  }\\n\\n  render() {\\n    return (\\n      <div>\\n        <input\\n          value={this.state.firstName}\\n          onChange={(event) =>\\n            this.setState({ firstName: event.target.value })\\n          }\\n        />\\n        <input\\n          value={this.state.lastName}\\n          onChange={(event) =>\\n            this.setState({ lastName: event.target.value })\\n          }\\n        />\\n      </div>\\n    )\\n  }\\n}\\n\")), mdx(\"p\", null, \"After:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=separate-use-states\"\n  }, \"const Names = () => {\\n  const [firstName, setFirstName] = React.useState('')\\n  const [lastName, setLastName] = React.useState('')\\n\\n  return (\\n    <div>\\n      <input\\n        value={firstName}\\n        onChange={(event) => setFirstName(event.target.value)}\\n      />\\n      <input\\n        value={lastName}\\n        onChange={(event) => setLastName(event.target.value)}\\n      />\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"This is pretty much the textbook example, and the split makes a lot of sense here. The two fields are pretty self-sufficient as they update on their own.\"), mdx(\"p\", null, \"But this isn't always the case. Sometimes, you might have state that actually updates together. In those situations, I don't think it makes sense to split it up into multiple useStates.\"), mdx(\"p\", null, \"One example that comes to mind is storing mouse coordinates (x/y). Using two \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useStates\"), \" seems super weird for something that always updates together, so I would use a single state object here:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=single-state-object\"\n  }, \"const App = () => {\\n  const [{ x, y }, setCoordinates] = React.useState({ x: 0, y: 0 })\\n\\n  return (\\n    <button\\n      onClick={(event) => {\\n        setCoordinates({ x: event.screenX, y: event.screenY })\\n      }}\\n    >\\n      Click, {x} {y}\\n    </button>\\n  )\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"form-state\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Form state\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#form-state\",\n    \"aria-label\": \"form state permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I think a single useState object also works fine for a simple generic form, where the structure might be different each time you're using it, and you only want to update one field at the time. You can't really have multiple \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useStates\"), \" for that, so a rudimentary custom hook implementation could look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=use-form\"\n  }, \"const useForm = <State extends Record<string, unknown>>(\\n  initialState: State\\n) => {\\n  const [values, setValues] = React.useState(initialState)\\n  const update = <Key extends keyof State>(name: Key, value: State[Key]) =>\\n    setValues((form) => ({ ...form, [name]: value }))\\n\\n  return [values, update] as const\\n}\\n\")), mdx(\"p\", null, \"So, for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useState\"), \", to decide if I want to split state up or not, I go by the following rule:\"), mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"State that updates together should live together.\"), mdx(\"h2\", {\n    \"id\": \"batching\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Batching\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#batching\",\n    \"aria-label\": \"batching permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Consider using a single state object over calling multiple \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useState\"), \" setters in a row. React is very good at batching those state updates together in synchronous event handlers, but still struggles with batching in async functions. This will get better with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/reactwg/react-18/discussions/21\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Automatic Batching in React 18\"), \", but structuring your code in a way so that you can reason about what state belongs together will help with readability and maintainability in the long run, regardless of performance concerns.\"), mdx(\"h2\", {\n    \"id\": \"usereducer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"useReducer\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#usereducer\",\n    \"aria-label\": \"usereducer permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I believe \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/hooks-reference.html#usereducer\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"useReducer\"), \" is still heavily underused. The main thinking around \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" seems to be that you only need it for \\\"complex state\\\". As I've written previously, it's pretty good for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"things-to-know-about-use-state#bonus2-toggling-state-with-usereducer\"\n  }, \"toggling state\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=toggle-with-use-reducer\"\n  }, \"const [value, toggleValue] = React.useReducer(previous => !previous, true)\\n\\n<button onClick={toggleValue}>Toggle</button>\\n\")), mdx(\"p\", null, \"It's also an often used way to implement \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"forceUpdate\"), \" (which almost every global state manager needs to inform subscribers about state changes if that state is kept outside of React):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=force-update-with-use-reducer\"\n  }, \"const forceUpdate = React.useReducer((state) => state + 1, 0)[1]\\n\")), mdx(\"p\", null, \"None of these implementations are particularly complex, and I think it really shows the flexibility of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \". That being said, it also shines when you update multiple parts of your state from different \\\"actions\\\", e.g. when implementing a multi-step wizard. You might want to initialize the second step depending on data chosen in the first step, or you might want to discard data of the third step when going back to the second.\"), mdx(\"p\", null, \"All these dependencies between parts of your state would need you to call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setState\"), \" multiple times in a row when you have independent \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useStates\"), \" (one for each step), and it would also get quite messy if you'd had a single state object.\"), mdx(\"h3\", {\n    \"id\": \"usereducer-tips\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"useReducer tips\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#usereducer-tips\",\n    \"aria-label\": \"usereducer tips permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"When I'm using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \", I try to adhere to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://redux.js.org/style-guide/style-guide\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"redux style guide\"), \". It's a great writeup that I can totally recommend, and most of the points also translate very well to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \", for example:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://redux.js.org/style-guide/style-guide#do-not-mutate-state\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Do Not Mutate State\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://redux.js.org/style-guide/style-guide#reducers-must-not-have-side-effects\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Reducers Must Not Have Side Effects\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://redux.js.org/style-guide/style-guide#model-actions-as-events-not-setters\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Model Actions as Events, not Setters\"))), mdx(\"h4\", {\n    \"id\": \"event-driven-reducers\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"event driven reducers\", mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#event-driven-reducers\",\n    \"aria-label\": \"event driven reducers permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Working immutably and not having side effects in reducers are things that most people will adhere to automatically, because it's in line with what react itself needs you do.\"), mdx(\"p\", null, \"Modelling actions as events is something that I really want to emphasize on, because it's one of the biggest advantages of reducers. By doing so, you can keep all your application logic \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"inside\"), \" the reducer instead of spread around various parts of the ui. This will not only make it easier to reason about state transitions, it will also make your logic super easy to test (really, pure functions are the easiest to test).\"), mdx(\"p\", null, \"To illustrate the concept, let's have a quick look at the standard \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"counter\"), \" example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=event-driven-reducer\"\n  }, \"const reducer = (state, action) => {\\n  // \\u2705 ui only dispatches events, logic is in the reducer\\n  switch (action) {\\n    case 'increment':\\n      return state + 1\\n    case 'decrement':\\n      return state - 1\\n  }\\n}\\n\\nfunction App() {\\n  const [count, dispatch] = React.useReducer(reducer, 0)\\n\\n  return (\\n    <div>\\n      Count: {count}\\n      <button onClick={() => dispatch('increment')}>Increment</button>\\n      <button onClick={() => dispatch('decrement')}>Decrement</button>\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"The logic is not very sophisticated (adding 1 or subtracting 1), but it's still \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"logic\"), \". We can extend that to allow an upper / lower bound, or customize the amount of numbers to increase / decrease with each click.\"), mdx(\"p\", null, \"All of that would happen \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"inside\"), \" the reducer. Compare that to an example where the reducer is \\\"dumb\\\" and just accepts the new number:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=🚨-dumb-reducer\"\n  }, \"const reducer = (state, action) => {\\n  switch (action.type) {\\n    // \\uD83D\\uDEA8 dumb reducer that doesn't do anything, logic is in the ui\\n    case 'set':\\n      return action.value\\n  }\\n}\\n\\nfunction App() {\\n  const [count, dispatch] = React.useReducer(reducer, 0)\\n\\n  return (\\n    <div>\\n      Count: {count}\\n      <button onClick={() => dispatch({ type: 'set', value: count + 1 })}>\\n        Increment\\n      </button>\\n      <button onClick={() => dispatch({ type: 'set', value: count - 1 })}>\\n        Decrement\\n      </button>\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"This works the same, but is not as extensible as the previous example. So generally speaking, try to avoid actions that have \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"set\"), \" in their name.\"), mdx(\"h4\", {\n    \"id\": \"passing-props-to-reducers\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"passing props to reducers\", mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#passing-props-to-reducers\",\n    \"aria-label\": \"passing props to reducers permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Another great trait of reducers is that you can inline them, or closure over props. This comes in very handy if you need access to props or server state (e.g. coming from a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"useQuery\"), \" hook) \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"inside\"), \" your reducer. Instead of \\\"copying\\\" these things into the reducer by using the state initializer, you can pass it to a function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=reducer-with-props\"\n  }, \"const reducer = (data) => (state, action) => {\\n  // \\u2705 you'll always have access to the latest\\n  // server state in here\\n}\\n\\nfunction App() {\\n  const { data } = useQuery(key, queryFn)\\n  const [state, dispatch] = React.useReducer(reducer(data))\\n}\\n\")), mdx(\"p\", null, \"This goes very well with the concept of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"practical-react-query#keep-server-and-client-state-separate\"\n  }, \"separating server and client state\"), \", and it actually wouldn't work at all if you'd pass \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialValue\"), \", because when the reducer first runs, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" will be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" (as we still need to fetch it first).\"), mdx(\"p\", null, \"So you'd wind up creating effects that try to sync the state into the reducer, which can get you in all sorts of troubles with background updates.\"), mdx(\"p\", null, \"Extending our event driven counter example where we fetch an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"amount\"), \" parameter from an endpoint would work pretty well with this approach. And of course, I'd use a custom hook for that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=use-counter-state\"\n  }, \"const reducer = (amount) => (state, action) => {\\n  switch (action) {\\n    case 'increment':\\n      return state + amount\\n    case 'decrement':\\n      return state - amount\\n  }\\n}\\n\\nconst useCounterState = () => {\\n  const { data } = useQuery(['amount'], fetchAmount)\\n  return React.useReducer(reducer(data ?? 1), 0)\\n}\\n\\nfunction App() {\\n  const [count, dispatch] = useCounterState()\\n\\n  return (\\n    <div>\\n      Count: {count}\\n      <button onClick={() => dispatch('increment')}>Increment</button>\\n      <button onClick={() => dispatch('decrement')}>Decrement</button>\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Note how we didn't need to change anything in the ui at all because of the clear separation provided by the custom hook \\uD83C\\uDF89\"), mdx(\"h2\", {\n    \"id\": \"rule-of-thumb\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Rule of thumb\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#rule-of-thumb\",\n    \"aria-label\": \"rule of thumb permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"In summary, my rule of thumb of when to use what would be:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if state updates independently - separate \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"useStates\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for state that updates together, or only one field at a time updates - a single \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"useState\"), \" object\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for state where user interactions update different parts of the state - \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"useReducer\"))), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Don't over useState #2: Putting props to useState #3: Things to know about useState #4: useState for one-time initializations The…","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/4b9244e41524bf53a06f77265d5061df/a6c62/usestate-vs-usereducer.jpg"}}}}},"pageContext":{"slug":"/use-state-vs-use-reducer","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}