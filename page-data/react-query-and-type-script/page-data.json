{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/react-query-and-type-script",
    "result": {"data":{"post":{"slug":"/react-query-and-type-script","title":"React Query and TypeScript","date":"16.05.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"TypeScript","slug":"type-script"}],"description":"Combine two of the most powerful tools for React Apps to produce great user experience, developer experience and type safety.","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Query and TypeScript\",\n  \"description\": \"Combine two of the most powerful tools for React Apps to produce great user experience, developer experience and type safety.\",\n  \"date\": \"2021-05-16T00:00:00.000Z\",\n  \"banner\": \"./react-query-typescript.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgABBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB5CeyZ2X/xAAZEAEBAQEBAQAAAAAAAAAAAAABAAIREiH/2gAIAQEAAQUC8oY6XxuWQJyX/8QAFhEBAQEAAAAAAAAAAAAAAAAAABEh/9oACAEDAQE/Aa1//8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEh/9oACAECAQE/AbGP/8QAGRAAAQUAAAAAAAAAAAAAAAAAEAABERIh/9oACAEBAAY/AlY60j//xAAZEAEAAwEBAAAAAAAAAAAAAAABABEhMUH/2gAIAQEAAT8hoG6lygIZ2PZQY60HK0l8BYrfJa9n/9oADAMBAAIAAwAAABBLP//EABoRAAICAwAAAAAAAAAAAAAAAAABETFRkfD/2gAIAQMBAT8QSSosbz7R/8QAGREAAwADAAAAAAAAAAAAAAAAAAERMZHw/9oACAECAQE/EGwSnHbP/8QAHBABAQEAAQUAAAAAAAAAAAAAAREAITFBUcHR/9oACAEBAAE/EHyDDxNeqKmDNbl2wKaC6iXCiP3BnwPEnKPrf//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"react query typescript\",\n    \"title\": \"react query typescript\",\n    \"src\": \"/blog/static/5bf14ba00a63f9f368079e6b9b260758/bbe0c/react-query-typescript.jpg\",\n    \"srcSet\": [\"/blog/static/5bf14ba00a63f9f368079e6b9b260758/46946/react-query-typescript.jpg 240w\", \"/blog/static/5bf14ba00a63f9f368079e6b9b260758/55489/react-query-typescript.jpg 480w\", \"/blog/static/5bf14ba00a63f9f368079e6b9b260758/bbe0c/react-query-typescript.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"hue12 photography\",\n    url: \"https://unsplash.com/@hue12_photography\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript\"), \" is \\uD83D\\uDD25 - this seems to be a common understanding now in the frontend community. Many developers expect libraries to either be written in TypeScript, or at least provide good type definitions. For me, if a library is written in TypeScript, the type definitions are the best documentation there is. It's never wrong because it directly reflects the implementation. I frequently look at type definitions before I read API docs.\"), mdx(\"p\", null, \"React Query was initially written in JavaScript (v1), and was then re-written to TypeScript with v2. This means that right now, there is very good support for TypeScript consumers.\"), mdx(\"p\", null, \"There are however a couple of \\\"gotchas\\\" when working with TypeScript due to how dynamic and unopinionated React Query is. Let's go through them one by one to make your experience with it even better.\"), mdx(\"h2\", {\n    \"id\": \"generics\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Generics\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#generics\",\n    \"aria-label\": \"generics permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"React Query heavily uses \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/2/generics.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Generics\"), \". This is necessary because the library does not actually fetch data for you, and it cannot know what \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"type\"), \" the data will have that your api returns.\"), mdx(\"p\", null, \"The TypeScript section in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/typescript\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"official docs\"), \" is not very extensive, and it tells us to explicitly specify the Generics that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" expects when calling it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=explicit-generics\"\n  }, \"function useGroups() {\\n  return useQuery<Group[], Error>('groups', fetchGroups)\\n}\\n\")), mdx(\"p\", null, \"Over time, React Query has added more Generics to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" hook (there are now four of them), mainly because more functionality was added. The above code works, and it will make sure that the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" property of our custom hook is correctly typed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Group[] | undefined\"), \" as well as that our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"error\"), \" will be of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Error | undefined\"), \". But it will not work like that for more advanced use-cases, especially when the other two Generics are needed.\"), mdx(\"h3\", {\n    \"id\": \"the-four-generics\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"The four Generics\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#the-four-generics\",\n    \"aria-label\": \"the four generics permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"This is the current definition of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" hook:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=useQuery\"\n  }, \"export function useQuery<\\n  TQueryFnData = unknown,\\n  TError = unknown,\\n  TData = TQueryFnData,\\n  TQueryKey extends QueryKey = QueryKey\\n>\\n\")), mdx(\"p\", null, \"There's a lot of stuff going on, so let's try to break it down:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TQueryFnData\"), \": the type returned from the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryFn\"), \". In the above example, it's \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Group[]\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TError\"), \": the type of Errors to expect from the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryFn\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Error\"), \" in the example.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TData\"), \": the type our \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"data\"), \" property will eventually have. Only relevant if you use the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"select\"), \" option, because then the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"data\"), \" property can be different from what the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryFn\"), \" returns. Otherwise, it will default to whatever the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryFn\"), \" returns.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TQueryKey\"), \": the type of our \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryKey\"), \", only relevant if you use the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryKey\"), \" that is passed to your \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"queryFn\"), \".\")), mdx(\"p\", null, \"As you can also see, all those Generics have default values, which means that if you don't provide them, TypeScript will fall back to those types. This works pretty much the same as default parameters in JavaScript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=default-parameters\"\n  }, \"function multiply(a, b = 2) {\\n  return a * b\\n}\\n\\nmultiply(10) // \\u2705 20\\nmultiply(10, 3) // \\u2705 30\\n\")), mdx(\"h3\", {\n    \"id\": \"type-inference\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Type Inference\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#type-inference\",\n    \"aria-label\": \"type inference permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"TypeScript works best if you let it infer (or figure out) what type something should be on its own. Not only does it make code easier to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"write\"), \" (because you don't have to type all the types \\uD83D\\uDE05), but it will also make it easier to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"read\"), \". In many instances, it can make code look exactly like JavaScript. Some simple examples of type inference would be:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=type-inference\"\n  }, \"const num = Math.random() + 5 // \\u2705 `number`\\n\\n// \\uD83D\\uDE80 both greeting and the result of greet will be string\\nfunction greet(greeting = 'ciao') {\\n  return `${greeting}, ${getName()}`\\n}\\n\")), mdx(\"p\", null, \"When it comes to Generics, they can also generally be inferred from their usage, which is super awesome. You could also provide them manually, but in many cases, you don't need to.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=generic-identity\"\n  }, \"function identity<T>(value: T): T {\\n  return value\\n}\\n\\n// \\uD83D\\uDEA8 no need to provide the generic\\nlet result = identity<number>(23)\\n\\n// \\u26A0\\uFE0F or to annotate the result\\nlet result: number = identity(23)\\n\\n// \\uD83D\\uDE0E infers correctly to `string`\\nlet result = identity('react-query')\\n\")), mdx(\"h3\", {\n    \"id\": \"partial-type-argument-inference\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Partial Type Argument Inference\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#partial-type-argument-inference\",\n    \"aria-label\": \"partial type argument inference permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"...doesn't exist in TypeScript yet (see this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/microsoft/TypeScript/issues/26242\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"open issue\"), \"). This basically means that if you provide \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"one\"), \" Generic, you have to provide \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"all\"), \" of them. But because React Query has default values for Generics, we might not notice right away that they will be taken. The resulting error messages can be quite cryptic. Let's look at an example where this actually backfires:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=default-generics\"\n  }, \"function useGroupCount() {\\n  return useQuery<Group[], Error>('groups', fetchGroups, {\\n    select: (groups) => groups.length,\\n    // \\uD83D\\uDEA8 Type '(groups: Group[]) => number' is not assignable to type '(data: Group[]) => Group[]'.\\n    // Type 'number' is not assignable to type 'Group[]'.ts(2322)\\n  })\\n}\\n\")), mdx(\"p\", null, \"Because we haven't provided the 3rd Generic, the default value kicks in, which is also \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Group[]\"), \", but we return \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \" from our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"select\"), \" function. One fix is to simply add the 3rd Generic:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=third-generic\",\n    \"metastring\": \"{3}\",\n    \"{3}\": true\n  }, \"function useGroupCount() {\\n  // \\u2705 fixed it\\n  return useQuery<Group[], Error, number>('groups', fetchGroups, {\\n    select: (groups) => groups.length,\\n  })\\n}\\n\")), mdx(\"p\", null, \"As long as we don't have Partial Type Argument Inference, we have to work with what we got.\"), mdx(\"p\", null, \"So what's the alternative?\"), mdx(\"h3\", {\n    \"id\": \"infer-all-the-things\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Infer all the things\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#infer-all-the-things\",\n    \"aria-label\": \"infer all the things permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Let's start by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" passing in any Generics at all and let TypeScript figure out what to do. For this to work, we need the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \" to have a good return type. Of course, if you inline that function without an explicit return type, you will have \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" - because that's what \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"axios\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" give you:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=inlined-queryFn\"\n  }, \"function useGroups() {\\n  // \\uD83D\\uDEA8 data will be `any` here\\n  return useQuery('groups', () =>\\n    axios.get('groups').then((response) => respone.data)\\n  )\\n}\\n\")), mdx(\"p\", null, \"If you (like me) like to keep your api layer separated from your queries, you'll need to add type definitions anyways to avoid \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"implicit any\"), \", so React Query can infer the rest:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=inferred-types\"\n  }, \"function fetchGroups(): Promise<Group[]> {\\n  return axios.get('groups').then((response) => response.data)\\n}\\n\\n// \\u2705 data will be `Group[] | undefined` here\\nfunction useGroups() {\\n  return useQuery('groups', fetchGroups)\\n}\\n\\n// \\u2705 data will be `number | undefined` here\\nfunction useGroupCount() {\\n  return useQuery('groups', fetchGroups, {\\n    select: (groups) => groups.length,\\n  })\\n}\\n\")), mdx(\"p\", null, \"Advantages of this approach are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no more manually specifying Generics\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"works for cases where the 3rd (select) and 4th (QueryKey) Generic are needed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"will continue to work if more Generics are added\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"code is less confusing / looks more like JavaScript\")), mdx(\"h3\", {\n    \"id\": \"what-about-error\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"What about error?\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#what-about-error\",\n    \"aria-label\": \"what about error permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"What about error, you might ask? Per default, without any Generics, error will be inferred to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unknown\"), \". This might sound like a bug, why is it not \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Error\"), \"? But it is actually on purpose, because in JavaScript, you can throw \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"anything\"), \" - it doesn't have to be of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Error\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=totally-legit-throw-statements\"\n  }, \"throw 5\\nthrow undefined\\nthrow Symbol('foo')\\n\")), mdx(\"p\", null, \"Since React Query is not in charge of the function that returns the Promise, it also can't know what type of errors it might produce. So \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unknown\"), \" is correct. Once TypeScript allows skipping some generics when calling a function with multiple generics (see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/microsoft/TypeScript/issues/10571\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"this issue for more information\"), \"), we could handle this better, but for now, if we need to work with errors and don't want to resort to passing Generics, we can narrow the type with an instanceof check:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=narrow-with-instanceof\"\n  }, \"const groups = useGroups()\\n\\nif (groups.error) {\\n  // \\uD83D\\uDEA8 this doesn't work because: Object is of type 'unknown'.ts(2571)\\n  return <div>An error occurred: {groups.error.message}</div>\\n}\\n\\n// \\u2705 the instanceOf check narrows to type `Error`\\nif (groups.error instanceof Error) {\\n  return <div>An error occurred: {groups.error.message}</div>\\n}\\n\")), mdx(\"p\", null, \"Since we need to make some kind of check anyways to see if we have an error, the instanceof check doesn't look like a bad idea at all, and it will also make sure that our error actually has a property message at runtime. This is also in line with what TypeScript has planned for the 4.4 release, where they'll introduce a new compiler flag \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useUnknownInCatchVariables\"), \", where catch variables will be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unknown\"), \" instead of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" (see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/microsoft/TypeScript/issues/41016\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"here\"), \").\"), mdx(\"h2\", {\n    \"id\": \"type-narrowing\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Type Narrowing\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#type-narrowing\",\n    \"aria-label\": \"type narrowing permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I rarely use destructuring when working with React Query. First of all, names like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"error\"), \" are quite universal (purposefully so), so you'll likely rename them anyway. Keeping the whole object will keep the context of what data it is or where the error is coming from. It will further help TypeScript to narrow types when using the status field or one of the status booleans, which it cannot do if you use destructuring:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=type-narrowing\"\n  }, \"const { data, isSuccess } = useGroups()\\nif (isSuccess) {\\n  // \\uD83D\\uDEA8 data will still be `Group[] | undefined` here\\n}\\n\\nconst groupsQuery = useGroups()\\nif (groupsQuery.isSuccess) {\\n  // \\u2705 groupsQuery.data will now be `Group[]`\\n}\\n\")), mdx(\"p\", null, \"This has nothing to do with React Query, it is just how TypeScript works. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/danvdk\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"@danvdk\"), \" has a good explanation for this behaviour\"), mdx(\"undefined\", null, mdx(\"blockquote\", {\n    \"className\": \"twitter-tweet\",\n    \"data-conversation\": \"none\",\n    \"data-dnt\": \"true\",\n    \"data-theme\": \"dark\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\",\n    \"lang\": \"en\",\n    \"dir\": \"ltr\"\n  }, \"The comment from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/TkDodo?ref_src=twsrc%5Etfw\"\n  }, \"@TkDodo\"), \" is exactly right, TypeScript does refinement on the types of individual symbols. Once you split them apart, it can't keep track of the relationship any more. Doing this in general would be computationally hard. It can also be hard for people.\"), \"\\u2014 Dan Vanderkam (@danvdk) \", mdx(\"a\", {\n    parentName: \"blockquote\",\n    \"href\": \"https://twitter.com/danvdk/status/1363614288103964672?ref_src=twsrc%5Etfw\"\n  }, \"February 21, 2021\"))), mdx(\"h2\", {\n    \"id\": \"type-safety-with-the-enabled-option\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Type safety with the enabled option\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#type-safety-with-the-enabled-option\",\n    \"aria-label\": \"type safety with the enabled option permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I've expressed my \\u2665\\uFE0F for the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./practical-react-query#the-enabled-option-is-very-powerful\"\n  }, \"enabled option\"), \" right from the start, but it can be a bit tricky on type level if you want to use it for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/dependent-queries\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"dependent queries\"), \" and disable your query for as long as some parameters are not yet defined:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=the-enabled-option\"\n  }, \"function fetchGroup(id: number): Promise<Group> {\\n  return axios.get(`group/${id}`).then((response) => response.data)\\n}\\n\\nfunction useGroup(id: number | undefined) {\\n  return useQuery(['group', id], () => fetchGroup(id), {\\n    enabled: Boolean(id),\\n  })\\n  // \\uD83D\\uDEA8 Argument of type 'number | undefined' is not assignable to parameter of type 'number'.\\n  //  Type 'undefined' is not assignable to type 'number'.ts(2345)\\n}\\n\")), mdx(\"p\", null, \"Technically, TypeScript is right, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"id\"), \" is possibly \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \": the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"enabled\"), \" option does not perform any type narrowing. Also, there are ways to bypass the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"enabled\"), \" option, for example by calling the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetch\"), \" method returned from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \". In that case, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"id\"), \" might really be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".\"), mdx(\"p\", null, \"I've found the best way to go here, if you don't like the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"non-null assertion operator\"), \", is to accept that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"id\"), \" can be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" and reject the Promise in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \". It's a bit of duplication, but it's also explicit and safe:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=explicit-id-check\",\n    \"metastring\": \"{3-5}\",\n    \"{3-5}\": true\n  }, \"function fetchGroup(id: number | undefined): Promise<Group> {\\n  // \\u2705 check id at runtime because it can be `undefined`\\n  return typeof id === 'undefined'\\n    ? Promise.reject(new Error('Invalid id'))\\n    : axios.get(`group/${id}`).then((response) => response.data)\\n}\\n\\nfunction useGroup(id: number | undefined) {\\n  return useQuery(['group', id], () => fetchGroup(id), {\\n    enabled: Boolean(id),\\n  })\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"optimistic-updates\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Optimistic Updates\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#optimistic-updates\",\n    \"aria-label\": \"optimistic updates permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Getting optimistic updates right in TypeScript is not an easy feat, so we've decided to add it as a comprehensive \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/examples/optimistic-updates-typescript\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"example\"), \" to the docs.\"), mdx(\"p\", null, \"The important part is: You have to explicitly type the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"variables\"), \" argument passed to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"onMutate\"), \" in order to get the best type inference. I don't fully comprehend why that is, but it again seems to have something to do with inference of Generics. Have a look \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/pull/1366#discussion_r538459890\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"at this comment\"), \" for more information.\"), mdx(\"h2\", {\n    \"id\": \"useinfinitequery\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"useInfiniteQuery\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#useinfinitequery\",\n    \"aria-label\": \"useinfinitequery permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"For the most parts, typing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useInfiniteQuery\"), \" is no different from typing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \". One noticeable gotcha is that the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pageParam\"), \" value, which is passed to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \", is typed as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \". Could be improved in the library for sure, but as long as it's \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \", it's probably best to explicitly annotate it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=useInfiniteQuery\"\n  }, \"type GroupResponse = { next?: number, groups: Group[] }\\nconst queryInfo = useInfiniteQuery(\\n  'groups',\\n  // \\u26A0\\uFE0F explicitly type pageParam to override `any`\\n  ({ pageParam = 0 }: { pageParam: GroupResponse['next']) => fetchGroups(groups, pageParam),\\n  {\\n    getNextPageParam: (lastGroup) => lastGroup.next,\\n  }\\n)\\n\")), mdx(\"p\", null, \"If \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fetchGroups\"), \" returns a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GroupResponse\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lastGroup\"), \" will have its type nicely inferred, and we can use the same type to annotate \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pageParam\"), \".\"), mdx(\"h2\", {\n    \"id\": \"typing-the-default-query-function\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Typing the default query function\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#typing-the-default-query-function\",\n    \"aria-label\": \"typing the default query function permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I am personally not using a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/default-query-function\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"defaultQueryFn\"), \", but I know many people are. It's a neat way to leverage the passed \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \" to directly build your request url. If you inline the function when creating the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryClient\"), \", the type of the passed \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryFunctionContext\"), \" will also be inferred for you. TypeScript is just so much better when you inline stuff :)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=defaultQueryFn\"\n  }, \"const queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      queryFn: async ({ queryKey: [url] }) => {\\n        const { data } = await axios.get(`${baseUrl}/${url}`)\\n        return data\\n      },\\n    },\\n  },\\n})\\n\")), mdx(\"p\", null, \"This just works, however, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"url\"), \" is inferred to type \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unknown\"), \", because the whole \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryKey\"), \" is an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unknown Array\"), \". At the time of the creation of the queryClient, there is absolutely no guarantee how the queryKeys will be constructed when calling \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \", so there is only so much React Query can do. That is just the nature of this highly dynamic feature. It's not a bad thing though because it means you now have to work defensively and narrow the type with runtime checks to work with it, for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=narrow-with-typeof\",\n    \"metastring\": \"{6-12}\",\n    \"{6-12}\": true\n  }, \"const queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      queryFn: async ({ queryKey: [url] }) => {\\n        // \\u2705 narrow the type of url to string so that we can work with it\\n        if (typeof url === 'string') {\\n          const { data } = await axios.get(`${baseUrl}/${url.toLowerCase()}`)\\n          return data\\n        }\\n        throw new Error('Invalid QueryKey')\\n      },\\n    },\\n  },\\n})\\n\")), mdx(\"p\", null, \"I think this shows quite well why \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unknown\"), \" is such a great (and underused) type compared to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \". It has become my favourite type lately - but that is subject for another blog post \\uD83D\\uDE0A.\"), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #…","timeToRead":6,"banner":{"childImageSharp":{"resize":{"src":"/static/5bf14ba00a63f9f368079e6b9b260758/a6c62/react-query-typescript.jpg"}}}}},"pageContext":{"slug":"/react-query-and-type-script","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}