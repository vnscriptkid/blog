{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/pedantic-index-signatures-in-type-script-4-1",
    "result": {"data":{"post":{"slug":"/pedantic-index-signatures-in-type-script-4-1","title":"Pedantic index signatures in TypeScript 4.1","date":"20.09.2020","tags":[{"name":"TypeScript","slug":"type-script"}],"description":"Accessing objects and arrays has never been safe in TypeScript, but this is about to change ...","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Pedantic index signatures in TypeScript 4.1\",\n  \"description\": \"Accessing objects and arrays has never been safe in TypeScript, but this is about to change ...\",\n  \"date\": \"2020-09-20T00:00:00.000Z\",\n  \"banner\": \"./books.png\",\n  \"tags\": [\"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAADnElEQVQ4yxXQ+zMbBgDA8fy07XbbbZqVKe7mVsyhXUsbOrV6BlVGJyvqlWBCilISWYgkkpRZaqj3e0EykhRLPOPR9UqNttzW/Tnf3T5/wkcwfE/ItNSP6TJfZqsCcTwKY6kphMWmUOZrgpgpEzKQL0Rx4zMmdXK2PQ72ttzsbKzi3Vhhd9vD3t4mG+ureP5YRGD5zofx4vPMyvwZlJxjShaIozmM3+u/YFYRwW+G+ww2pqHKi6ZLVcuSdYKnPSaemHXMjA1gMevQtynxuB14VuwIWuI/oivLh5HC84yX+DFS5Ie94SKOxi8ZqvyKMaMC6+N8xs11LNtnWV6YxDo5zJrbicfjosesRVNfxeqKHbfbiUAS9iH1Me+jS3yPnzM/oD/3Y2w1ATxrDmH+xwBqM8IpTY6gIDsFTUMNXdpmegxKNE01yKWFmLRKPMsLOB1WXM45BKJgP6Tp0WikYjQyMW0VYjrkaagqk5HmfE1W4hVys5L4/k4SabdiuCkKJyX+EjkZ8WRn3KRYkkldTTFyqQSFTIIgPymO4Y4WVkd78U4NsjM3wb7TxpBJS5ivkMufC7nq78M1fx+uB5zjVkgQCReDiA++wJUAX4J9PyHkwqeEBgqJjQhGoKko5GBxipf2MQ7sExzaxjl2WXk+N4rLYsDZ3YGjU82SthlX2yOGC9Mx3b6GITsGoyQWY2kCxioxqaJLfHs1HMETdSNnLzY5fbnL2eE+Z4d7nB7scHbg5d+zY969fcU/bw75+90bXh//ifPXRpwWOUvmEmz6ApZ0hXRXZCIWRZFyPQLBhOUxr9ZX2JobY2duhBcuK4fryxx51zjadHOys8bbg33OTk84er7GYmcVow136avMpFcuYUrfhEVdT15yHPmpIgTtjXK82xt4tz24HVbWXTa23c/Y2fCwarMybFAzpFNh6+9mslOFriybjtoirIMmbDN9jI9YmJvuJ1EUhej/w+hgf8QxkXS2tbJgn2dtc53Dk784en2Md3eLgT4zD+Sl1FUVoKwrpa66gKbaIsp+yCBPHEdybASygmzqq6XIpfcRFNxO5V56EiV3xLTUVtBjbGdmagyny8HoUD/lhXmIE0Qkx17mRlQIsZGhJERHkpv2DQ+ri9FqWtHr9Bj0nahbWhBUF0lQKqox/KRC36pE3aCgSV5FbXkZClk51aXF3E1LoigniweVMrrNJnp/6WFo8CnjE5P09fVjNprQadtRNj7kPxtgb9cySEN0AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"books\",\n    \"title\": \"books\",\n    \"src\": \"/blog/static/5a2ba76c8ef491afb0aa86084b25aec7/7d769/books.png\",\n    \"srcSet\": [\"/blog/static/5a2ba76c8ef491afb0aa86084b25aec7/5243c/books.png 240w\", \"/blog/static/5a2ba76c8ef491afb0aa86084b25aec7/ab158/books.png 480w\", \"/blog/static/5a2ba76c8ef491afb0aa86084b25aec7/7d769/books.png 960w\", \"/blog/static/5a2ba76c8ef491afb0aa86084b25aec7/e04d8/books.png 1258w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Sincerely Media\",\n    url: \"https://unsplash.com/@sincerelymedia\",\n    mdxType: \"Attribution\"\n  }), mdx(\"p\", null, \"TypeScript 4.1 beta was \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"announced recently\"), \",\\nand it introduces many new and exciting features.\\nWhile I won't pretend to understand (yet) what you will be able to do with\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"template literal types\"), \"\\n(people have built a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/buildsghost/status/1301976526603206657\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"JSON parser\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"on type level\"), \" with this already \\uD83E\\uDD2F)\\nor \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#recursive-conditional-types\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"recursive conditional types\"), \",\\nI'm pretty sure I will be using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#no-unchecked-indexed-access\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"pedantic index signature checks\"), \"\\nwhenever I can.\"), mdx(\"h2\", {\n    \"id\": \"what-is-wrong-with-index-signatures\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"What is wrong with index signatures\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-is-wrong-with-index-signatures\",\n    \"aria-label\": \"what is wrong with index signatures permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"If you add an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"index signature\"), \" to an object, you tell TypeScript that you don't know exactly which keys will be in that object,\\nyou only know which \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"type\"), \" the key will have.\\nThis is very useful if you build objects where you really don't know the keys, for example, normalized objects where the keys are ids of database records:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=index-signature\"\n  }, \"type Widget = {\\n  id: string\\n  title: string\\n}\\n\\ntype WidgetIndex = Record<string, Widget>\\n\\n// alternate syntax:\\ntype WidgetIndex = {\\n  [id: string]: Widget\\n}\\n\")), mdx(\"p\", null, \"So naturally, when you try to retrieve a Widget from that index via it's id, the access \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"should\"), \" yield \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Widget | undefined\"), \".\\nBut alas, it does not:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=unsafe-access\",\n    \"metastring\": \"{6-11}\",\n    \"{6-11}\": true\n  }, \"type Widget = {\\n  id: string\\n  title: string\\n}\\n\\nconst widgetIndex: Record<string, Widget> = {\\n  widget1: { id: 'widget1', title: 'Foo' },\\n  widget2: { id: 'widget2', title: 'Bar' },\\n}\\n\\nwidgetIndex['helloWorld'].title.toUpperCase()\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBA6glgEwOYWFAvFA3gKCvqRALigGdgAnOAOyTwODmABsITyracBfHHAYwD21clADuiFMACS1BBAAeJAEoQhFBAB4ONJABpYk1AD4M2evgnJUARhJZCCEgHIrUm84OMWbKM4BigoLOUNx6FuJGwABM9o4ubqjRnlDerC4AQgCGFCFhPHyJMnKKANrOABYQzMyCMIIUzAjOALoAdGkQHYIAqmCQFADCWaQQABQAlEA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"Yes, TypeScript is perfectly fine with that code, even though this will clearly err at runtime.\\nThis is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" what I expect from a static type checker that aims at giving you safety at runtime,\\nand I was really surprised when I found out that TypeScript behaves like that (and dare I say: a bit disappointed as well).\"), mdx(\"p\", null, \"And it gets worse. Even if you, as a responsible developer, anticipate that the index access might give you \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" at runtime,\\nand thus implement a fallback, TypeScript will completely ignore it and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" type check it at all, because on type level, the index\\naccess will \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"always\"), \" return a value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=unsafe-fallback\",\n    \"metastring\": \"{11}\",\n    \"{11}\": true\n  }, \"type Widget = {\\n  id: string\\n  title: string\\n}\\n\\nconst widgetIndex: Record<string, Widget> = {\\n  widget1: { id: 'widget1', title: 'Foo' },\\n  widget2: { id: 'widget2', title: 'Bar' },\\n}\\n\\nconst title: string = widgetIndex['helloWorld']?.title ?? {\\n  thisIs: 'completely Untyped',\\n}\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBA6glgEwOYWFAvFA3gKCvqRALigGdgAnOAOyTwODmABsITyracBfHHAYwD21clADuiFMACS1BBAAeJAEoQhFBAB4ONJABpYk1AD4M2evgnJUARhJZCCEgHIrUm84OMWbKM4BigoLOUNx6FuJGwABM9o4ubqjRnlDerC4AQgCGFCFhPHxCImhpvjq0ZokycooA2s4AFhDMzIIwghTMCM4AugD8AHSlUH192KkNcKTSpC5CALZgrMDNIFAAqtSgkN2hQA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"h2\", {\n    \"id\": \"saferecord-to-the-rescue\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"SafeRecord to the rescue\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#saferecord-to-the-rescue\",\n    \"aria-label\": \"saferecord to the rescue permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Like many others, I believe this to be a big flaw of the language itself.\\nBut luckily, you can always implement your own types and use them instead of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Record\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=safe-record\"\n  }, \"type SafeRecord<Key extends string | number | symbol, Value> = Record<\\n  Key,\\n  Value | undefined\\n>\\n\")), mdx(\"p\", null, \"With that type, all values will also include \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \", so whenever you retrieve a value from a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SafeRecord\"), \", you have\\nto check for undefined first.\\nThis is a fine solution to the problem, but it has some other drawbacks.\\nFor example, calling \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Object.values\"), \" on a SafeRecord will now give you an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array<T | undefined>\"), \", even though it's really impossible for the\\nvalues to actually be undefined. I still advocate for using SafeRecords whenever an index access is involved.\"), mdx(\"h2\", {\n    \"id\": \"what-about-arrays\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"What about Arrays?\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-about-arrays\",\n    \"aria-label\": \"what about arrays permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Well, Arrays are just as affected. After all, Arrays are (mostly) just objects where the index is a number.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=unsafe-arrays\"\n  }, \"const strings: Array<string> = ['one', 'two', 'three']\\n\\nstrings[999].toUpperCase()\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/MYewdgzgLgBNBOBLMBzCAuGBBe8CGAngDwLIoB8MAvDANoDk4ApvQDQz1QDuIbHUAC3hMWAXQBQ40qgi0AnAtEA6KCACqABw1N4AYTwQmACgCUQA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"p\", null, \"Oh boy, we should just go back to plain ES6 :(\"), mdx(\"p\", null, \"At least, we are not going to directly access index 999 in Arrays that often.\\nIn practice, I have found that when an Array has a variable length, we often want to access the first element of that Array.\\nIf I find myself needing to access \", \"[1]\", \" or \", \"[2]\", \" a lot, I can usually use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Tuples\"), \".\"), mdx(\"p\", null, \"So how can we fix accessing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\", \"[0]\"), \"? Yes, we can do a manual length check upfront, but no one will force us to.\\nHaving to think about this every single time is quite brittle and error prone, so can we enforce it on type level?\"), mdx(\"h2\", {\n    \"id\": \"nonemptylist\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"NonEmptyList\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#nonemptylist\",\n    \"aria-label\": \"nonemptylist permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The concept of a non empty list exists in many programming languages,\\ne.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://hackage.haskell.org/package/NonEmptyList\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Haskell\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://typelevel.org/cats/datatypes/nel.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Scala\"), \".\\nIt basically means: A list with a length of at least one, so accessing the first element of that list will never fail.\"), mdx(\"p\", null, \"TypeScript 4.0 introduced \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#variadic-tuple-types\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"variadic tuple types\"), \",\\nwhich let us tackle that specific problem:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=non-empty-array\"\n  }, \"type NonEmptyArray<T> = [T, ...Array<T>]\\nconst isNonEmpty = <T extends unknown>(\\n  array: Array<T>\\n): array is NonEmptyArray<T> => array.length > 0\\n\")), mdx(\"p\", null, \"This basically gives us a variadic tuple type where the first element is always defined, and a\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"user-defined type guard\"), \"\\nthat assures an Array is really non-empty.\\nSo if you want to force people to give you a non-empty Array so that you can safely access the first value,\\njust type your function with a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"NonEmptyArray\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=forced-empty-check\",\n    \"metastring\": \"{7-15}\",\n    \"{7-15}\": true\n  }, \"type NonEmptyArray<T> = [T, ...Array<T>]\\nconst isNonEmpty = <T extends unknown>(\\n  array: Array<T>\\n): array is NonEmptyArray<T> => array.length > 0\\n\\nconst strings: Array<string> = ['one', 'two', 'three']\\n\\nconst firstToUpper = (list: NonEmptyArray<string>) => list[0].toUpperCase()\\n\\n// this will type-err\\nfirstToUpper(strings)\\n\\n// this is fine\\nif (isNonEmpty(strings)) {\\n  firstToUpper(strings)\\n}\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?#code/C4TwDgpgBAcg9gOwKIFsygIICcsEMQA8AKgHxQC8UA2kQDRQB0T2ehpAugFADGiAzsCgBLPvGRpQFKMSgQAHsAgIAJnygBXBAGsEcAO4ISAClw58ALigt8xEgEpLp1sLVjU6ENbZlyZJ-gYAGyUAc2AACygyAAZOHn5BASwhBBC+Sy8CJJSQn2oAckQIfPp84D04Eqgy8KwIYq54hAEoADMhLAEiOABVMEgsKSNAkWBLNwlPM0Js1PsKMhGBKmj2BmBe-ogsAGFcPggjOziAehOoCJEoPSFAwIvwCABabaxOds7gbr6Bo1m046cM4XcJXK7tBAQThCVpQIwiCYeP7AZKpPh2OxQADenCgeLaHS6m1+-3RnAAvkA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"TypeScript playground\")), mdx(\"h2\", {\n    \"id\": \"--nouncheckedindexedaccess\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"--noUncheckedIndexedAccess\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#--nouncheckedindexedaccess\",\n    \"aria-label\": \"  nouncheckedindexedaccess permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"What does all of this have to do with TypeScript 4.1 you might ask?\\nWell, as this has been a feature request of many developers over the course of the years, but the change is also quite breaking for many existing apps,\\nthe TypeScript team has decided to introduce a new compiler flag with version 4.1.\\nThe flag is called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/microsoft/TypeScript/pull/39560\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"noUncheckedIndexedAccess\"), \"\\nand it is going to solve the problem for Objects and Arrays alike by making sure that an index access will always return a possibly undefined value.\\nMapping over an Array or using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Object.values\"), \" will still be safe, so this doesn't suffer from the same drawbacks as the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SafeRecord\"), \" type.\"), mdx(\"p\", null, \"Here is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/play?noUncheckedIndexedAccess=true&ts=4.1.0-dev.20200920#code/PTACDsHsFVwYwBYFM4GskBMCS4NIB6YCCccSAzuQFBVyTjkAuABEwE4CW4A5uQFzMibNgEMAngB52XbgD5mAXmYBtAOT0kqgDTNVjAO6RtuxgjZJNAXRrSe5ZQE4nlgHSMYABw9I2AYRHkSAAUAJRAA\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"link\"), \"\\nto the latest TypeScript playground beta with that flag enabled so you can play around if you want.\"), mdx(\"p\", null, \"It will still take about two months until that version is released, but I am \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"really\"), \" looking forward to it \\uD83C\\uDF89.\"), mdx(Comments, {\n    mdxType: \"Comments\"\n  }, \"Let me know how you like the new TypeScript beta in the comments below \\u2B07\\uFE0F\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"TypeScript 4.1 beta was  announced recently ,\nand it introduces many new and exciting features.\nWhile I won't pretend to understand (yet…","timeToRead":3,"banner":{"childImageSharp":{"resize":{"src":"/static/5a2ba76c8ef491afb0aa86084b25aec7/73f08/books.png"}}}}},"pageContext":{"slug":"/pedantic-index-signatures-in-type-script-4-1","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}