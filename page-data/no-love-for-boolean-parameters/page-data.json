{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/no-love-for-boolean-parameters",
    "result": {"data":{"post":{"slug":"/no-love-for-boolean-parameters","title":"No love for boolean parameters","date":"28.02.2021","tags":[{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"},{"name":"React","slug":"react"}],"description":"Innocent looking boolean parameters, or flags, are often the reason for hard to maintain legacy code. Resist the urge of adding them!","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"No love for boolean parameters\",\n  \"description\": \"Innocent looking boolean parameters, or flags, are often the reason for hard to maintain legacy code. Resist the urge of adding them!\",\n  \"date\": \"2021-02-28T00:00:00.000Z\",\n  \"banner\": \"./boolean.jpg\",\n  \"tags\": [\"JavaScript\", \"TypeScript\", \"React\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"67.08333333333334%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMEBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAABxQ6UTRBH/8QAGhAAAgIDAAAAAAAAAAAAAAAAAQIAERASQf/aAAgBAQABBQJlNbsJc46g4//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ARn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAVEAEBAAAAAAAAAAAAAAAAAAAgIf/aAAgBAQAGPwKL/8QAGhABAQEAAwEAAAAAAAAAAAAAAQARITFBof/aAAgBAQABPyHnM7bQY1Z8XaeWIoN//9oADAMBAAIAAwAAABBr7//EABYRAQEBAAAAAAAAAAAAAAAAAAEQMf/aAAgBAwEBPxAzSf/EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EEn/xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMUFRcf/aAAgBAQABPxBXQ8NwARZsTcAXhlKvKNfZmQXSmOCAfLn/2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"boolean\",\n    \"title\": \"boolean\",\n    \"src\": \"/blog/static/f3b77119458208462b29c0eebd2ca805/bbe0c/boolean.jpg\",\n    \"srcSet\": [\"/blog/static/f3b77119458208462b29c0eebd2ca805/46946/boolean.jpg 240w\", \"/blog/static/f3b77119458208462b29c0eebd2ca805/55489/boolean.jpg 480w\", \"/blog/static/f3b77119458208462b29c0eebd2ca805/bbe0c/boolean.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Alexander Sinn\",\n    url: \"https://unsplash.com/@swimstaralex\",\n    mdxType: \"Attribution\"\n  }), mdx(\"p\", null, \"Ah, booleans. 0 or 1, true or false. Always either one of them, never something in between. So simple and predictable. At the end of the day, all code we write winds up in lots of zeros and ones.\"), mdx(\"p\", null, \"There is nothing wrong with booleans per se. We use them for conditions every day:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=boolean-condition\"\n  }, \"// \\u2705 boolean condition\\nif (user.age() < legalAge) {\\n  return 'Sorry, you are too young to use this service'\\n}\\n\")), mdx(\"p\", null, \"But using them for parameters to a function can be an indication of bad design for various reasons:\"), mdx(\"h2\", {\n    \"id\": \"single-responsibility-principle\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Single responsibility principle\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#single-responsibility-principle\",\n    \"aria-label\": \"single responsibility principle permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"A function should do one thing, and one thing only. Passing a \\\"flag\\\" to it often indicates that a function does two things at once, thus violating \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Single-responsibility_principle\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"this principle\"), \". For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=single-responsibility\"\n  }, \"// \\uD83D\\uDEA8 booleans as a function parameter\\nfunction createReport(user: User, sendEmail: boolean) {\\n  // create the report here\\n  const reportData = ...\\n\\n  if (sendEmail) {\\n    sendReport(user.email, reportData)\\n  }\\n  return reportData\\n}\\n\")), mdx(\"p\", null, \"There seem to be some cases where we want to send the report as email directly after creating it, and some cases where we don't. But why entangle this in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createReport\"), \" function? That function should only create the report, and nothing else. The caller can decide what they want to do with it.\"), mdx(\"h2\", {\n    \"id\": \"they-are-confusing\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"They are confusing\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#they-are-confusing\",\n    \"aria-label\": \"they are confusing permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Flags can be confusing, especially in languages where you don't have named parameters. Take for example this signature of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/equals.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"equals\"), \" from the Kotlin standard library:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-kt:title=equals-with-ignore-case-flag\"\n  }, \"fun String?.equals(other: String?, ignoreCase: Boolean): Boolean\\n\\n// Returns true if this string is equal to other, optionally ignoring character case.\\n\")), mdx(\"p\", null, \"As opposed to the first example, the function doesn't do two things at once, it does one thing in two different \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"variations\"), \" - an important difference. This can be highly confusing when you have to read the call-side that looks something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-kt:title=???\"\n  }, \"\\\"foo\\\".equals(\\\"bar\\\", true)\\n\\\"foo\\\".equals(\\\"bar\\\", false)\\n\")), mdx(\"p\", null, \"How should we know what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" means in this context. Even worse, what would \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" mean? Does it maybe negate the equals comparison? \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Scala\"), \" has solved this differently with two methods: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.scala-lang.org/api/2.12.3/scala/collection/immutable/StringOps.html#equals(x$1:Any):Boolean\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"equals\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.scala-lang.org/api/2.12.3/scala/collection/immutable/StringOps.html#equalsIgnoreCase(x$1:String):Boolean\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"equalsIgnoreCase\"), \". Each does one only one thing - no guesswork here.\"), mdx(\"h3\", {\n    \"id\": \"more-guesswork\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"More guesswork\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#more-guesswork\",\n    \"aria-label\": \"more guesswork permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Before you look it up \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Iterable.html#sort(boolean,%20groovy.lang.Closure)\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"here\"), \" - what do you think this boolean flag on Groovy's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List.sort\"), \" method means:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-groovy:title=sort\"\n  }, \"[\\\"hello\\\",\\\"hi\\\",\\\"hey\\\"].sort(false) { it.length() }\\n\")), mdx(\"p\", null, \"In case it isn't obvious to everyone:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mutate\"), \" - false will always cause a new list to be created, true will mutate lists in place\")), mdx(\"p\", null, \"Totally logical and intuitive api, not confusing at all \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\"), mdx(\"h2\", {\n    \"id\": \"impossible-states\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Impossible states\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#impossible-states\",\n    \"aria-label\": \"impossible states permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Booleans make it easy to create impossible states. Suppose you have a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"metric\"), \" of some sorts, and you want to format that. It might be a \\\"normal\\\" number, but it might also be a percentage value. So you decide to model the formatting function like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=format-metric\"\n  }, \"function formatMetric(value: number, isPercent: boolean): string {\\n  if (isPercent) {\\n    return `${value * 100}%`\\n  }\\n  return String(metric)\\n}\\n\")), mdx(\"p\", null, \"This is rather rudimentary number formatting function, but apart from that, it doesn't look too bad. Frankly, the first \\\"flag\\\" you add to a function usually looks \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very innocent\"), \".\"), mdx(\"h3\", {\n    \"id\": \"the-second-flag\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"The second flag\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#the-second-flag\",\n    \"aria-label\": \"the second flag permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Requirements change over time (as they tend to do), and now we have to support currencies for some of our metrics as well. Starting from the above formatting function, we are tempted to add \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"another\"), \" flag, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isCurrency\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=ðŸš¨-currency-formatting\",\n    \"metastring\": \"{1,5-7}\",\n    \"{1,5-7}\": true\n  }, \"function formatMetric(\\n  value: number,\\n  isPercent: boolean,\\n  isCurrency: boolean\\n): string {\\n  if (isPercent) {\\n    return `${value * 100}%`\\n  }\\n  if (isCurrency) {\\n    return // imagine some currency formatting is returned here\\n  }\\n  return String(metric)\\n}\\n\")), mdx(\"p\", null, \"Our code works, we write tests, add the currency flag if we have a currency metric, and all is well.\"), mdx(\"p\", null, \"Except it isn't.\"), mdx(\"p\", null, \"Adding one boolean doesn't add \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"one more state\"), \" - the amount of states grow exponentially. Two booleans means four states, three booleans means eight possible states etc. What happens if we call our above function with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"formatMetric(100, true, true)\\n\")), mdx(\"p\", null, \"The answer is: you can't know. It's an implementation detail which flag is checked first. It's also an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"impossible state\"), \": A metric cannot be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"percent\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"currency\"), \" at the same time. Such impossible states are frequently introduced with boolean parameters. I recently encountered a function with 8 booleans as input - turns out, it only had 3 actual states, the rest were variations thereof.\"), mdx(\"h3\", {\n    \"id\": \"resist-the-urge\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Resist the urge\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#resist-the-urge\",\n    \"aria-label\": \"resist the urge permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"To avoid impossible states, resist the urge of adding the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"first\"), \" boolean parameter. It is infinitely easier for humans to extend existing patterns instead of recognizing anti-patterns and refactoring them. If there is one boolean, there will be a second. If we start of with an enumeration of possible states, it is much more likely that this will be extended instead:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=âœ…-metric-variant\",\n    \"metastring\": \"{1,2}\",\n    \"{1,2}\": true\n  }, \"function formatMetric(value: number, variant?: 'percent'): string {\\n  if (variant === 'percent') {\\n    return `${value * 100}%`\\n  }\\n  return String(metric)\\n}\\n\")), mdx(\"p\", null, \"Now we can extend the variant to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'percent' | 'currency'\"), \", and only have three states to work with instead of four. Of course, you can also explicitly include the default (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"standard\"), \") variant instead of using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"undefined\"), \".\"), mdx(\"h3\", {\n    \"id\": \"moar-advantages\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Moar advantages\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#moar-advantages\",\n    \"aria-label\": \"moar advantages permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Further advantages of a single variant property include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Better type safety\", mdx(\"br\", null), \"\\nWe've already covered readability, but it's also very easy to mix flags up, and because they have the same type (boolean), the compiler won't tell you about it. You can work around this by using a single options object, which is quite popular in JavaScript.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Exhaustive matching \", mdx(\"br\", null), \"\\nI've written about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./exhaustive-matching-in-type-script\"\n  }, \"exhaustive matching in TypeScript\"), \" before, and it also comes in very handy in this example. The compiler will then tell us where we need to adapt our code when we add a new variant. CDD, compiler-driven-development:\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=exhaustive-variants\"\n  }, \"type MetricVariant = 'standard' | 'percent' | 'currency'\\nfunction formatMetric(\\n  value: number,\\n  variant: MetricVariant = 'standard'\\n): string {\\n  switch (variant) {\\n    case 'percent':\\n      return `${value * 100}%`\\n    case 'currency':\\n      return // imagine some currency formatting is returned here\\n    case 'standard':\\n      return String(metric)\\n  }\\n}\\n\")), mdx(\"p\", null, \"We also do the same when creating React components, or have you seen a Button with an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"isPrimary\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"isSecondary\"), \" flag? Of course not - because how can they be both at the same time?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=button-variants\"\n  }, \"// \\uD83D\\uDEA8 Don't do this\\n<Button isPrimary isSecondary />\\n\\n// \\u2705 Do this\\n<Button variant=\\\"primary\\\" />\\n\")), mdx(\"h2\", {\n    \"id\": \"the-wrong-abstraction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"The wrong abstraction\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-wrong-abstraction\",\n    \"aria-label\": \"the wrong abstraction permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Oftentimes, flags are added because we see similarities to existing code, and we don't want to repeat ourselves, keeping everything \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"DRY\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Here is a function that looks almost like what I want, I just need to add this one flag, because it's slightly different.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This component looks like I could use it for my case as well, I just need a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"withPadding\"), \" property added so that it fits.\")), mdx(\"p\", null, \"There is lots of good literature available on that topic, showing why we shouldn't do this and what we could do instead:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"The wet codebase\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://kentcdodds.com/blog/inversion-of-control\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Inversion of control\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://kentcdodds.com/blog/aha-programming\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"AHA programming\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"The wrong abstraction\"))), mdx(\"p\", null, \"I can recommend them all, and for starters, resist the urge of adding the next boolean parameter to your codebase.\"), mdx(Comments, {\n    mdxType: \"Comments\"\n  }, \"No matter if you like booleans, or not, or both at the same time, leave a comment below \\u2B07\\uFE0F\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Ah, booleans. 0 or 1, true or false. Always either one of them, never something in between. So simple and predictable. At the end of the dayâ€¦","timeToRead":3,"banner":{"childImageSharp":{"resize":{"src":"/static/f3b77119458208462b29c0eebd2ca805/a6c62/boolean.jpg"}}}}},"pageContext":{"slug":"/no-love-for-boolean-parameters","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}