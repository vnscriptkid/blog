{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/react-query-error-handling",
    "result": {"data":{"post":{"slug":"/react-query-error-handling","title":"React Query Error Handling","date":"10.09.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"After covering the sunshine cases of data fetching, it's time to look at situations where things don't go as planned and \"Something went wrong...\"","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Query Error Handling\",\n  \"description\": \"After covering the sunshine cases of data fetching, it's time to look at situations where things don't go as planned and \\\"Something went wrong...\\\"\",\n  \"date\": \"2021-09-10T00:00:00.000Z\",\n  \"banner\": \"./error-handling.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"73.33333333333334%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgABBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeOGTJx//8QAGRABAAIDAAAAAAAAAAAAAAAAAQACEBFB/9oACAEBAAEFAiq1xyJqf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAARIDH/2gAIAQEABj8Cc6f/xAAYEAEBAQEBAAAAAAAAAAAAAAARIQEAEP/aAAgBAQABPyHUZDPZVE4j2QFO/9oADAMBAAIAAwAAABDbH//EABcRAQEBAQAAAAAAAAAAAAAAAAEAEUH/2gAIAQMBAT8QU5Jl/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8QBn//xAAbEAEAAgIDAAAAAAAAAAAAAAABESEAURAxYf/aAAgBAQABPxDYIbvmJfQVrHoMmLC0FpIz/9k=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"error handling\",\n    \"title\": \"error handling\",\n    \"src\": \"/blog/static/81915dee3ffd49bc0840fbb93cb81b71/bbe0c/error-handling.jpg\",\n    \"srcSet\": [\"/blog/static/81915dee3ffd49bc0840fbb93cb81b71/46946/error-handling.jpg 240w\", \"/blog/static/81915dee3ffd49bc0840fbb93cb81b71/55489/error-handling.jpg 480w\", \"/blog/static/81915dee3ffd49bc0840fbb93cb81b71/bbe0c/error-handling.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Sigmund\",\n    url: \"https://unsplash.com/@sigmund\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, \"Handling errors is an integral part of working with asynchronous data, especially data fetching. We have to face it: Not all requests will be successful, and not all Promises will be fulfilled.\"), mdx(\"p\", null, \"Oftentimes, it is something that we don't focus on right from the beginning though. We like to handle \\\"sunshine cases\\\" first where error handling becomes an afterthought.\"), mdx(\"p\", null, \"However, not thinking about how we are going to handle our errors might negatively affect user experience. To avoid that, let's dive into what options React Query offers us when it comes to error handling.\"), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Prerequisites\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"React Query needs a rejected Promise in order to handle errors correctly. Luckily, this is exactly what you'll get when you work with libraries like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://axios-http.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"axios\"), \".\"), mdx(\"p\", null, \"If you are working with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"the fetch API\"), \" or other libraries that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"do not\"), \" give you a rejected Promise on erroneous status codes like 4xx or 5xx, you'll have to do the transformation yourself in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \". This is covered in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/query-functions#usage-with-fetch-and-other-clients-that-do-not-throw-by-default\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"the official docs\"), \".\"), mdx(\"h2\", {\n    \"id\": \"the-standard-example\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"The standard example\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-standard-example\",\n    \"aria-label\": \"the standard example permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Let's see how most examples around displaying errors look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=the-standard-example\"\n  }, \"function TodoList() {\\n  const todos = useQuery(['todos'], fetchTodos)\\n\\n  if (todos.isLoading) {\\n    return 'Loading...'\\n  }\\n\\n  // \\u2705 standard error handling\\n  // could also check for: todos.status === 'error'\\n  if (todos.isError) {\\n    return 'An error occurred'\\n  }\\n\\n  return (\\n    <div>\\n      {todos.data.map((todo) => (\\n        <Todo key={todo.id} {...todo} />\\n      ))}\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Here, we're handling error situations by checking for the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"isError\"), \" boolean flag (which is derived from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"status\"), \" enum) given to us by React Query.\"), mdx(\"p\", null, \"This is certainly okay for some scenarios, but has a couple of drawbacks, too:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"It doesn't handle background errors very well: Would we really want to unmount our complete Todo List just because a background refetch failed? Maybe the api is temporarily down, or we reached a rate limit, in which case it might work again in a few minutes. You can have a look at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\"), \" to find out how to improve that situation.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"It can become quite boilerplate-y if you have to do this in every component that wants to use a query.\"))), mdx(\"p\", null, \"To solve the second issue, we can use a great feature provided directly by React itself:\"), mdx(\"h2\", {\n    \"id\": \"error-boundaries\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Error Boundaries\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#error-boundaries\",\n    \"aria-label\": \"error boundaries permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Error Boundaries\"), \" are a general concept in React to catch runtime errors that happen during rendering, which allows us to react (pun intended) properly to them and display a fallback UI instead.\"), mdx(\"p\", null, \"This is nice because we can wrap our components in Error Boundaries at any granularity we want, so that the rest of the UI will be unaffected by that error.\"), mdx(\"p\", null, \"One thing that Error Boundaries \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cannot\"), \" do is catch asynchronous errors, because those do not occur during rendering. So to make Error Boundaries work in React Query, the library internally catches the error for you and re-throws it in the next render cycle so that the Error Boundary can pick it up.\"), mdx(\"p\", null, \"I think this is a pretty genius yet simple approach to error handling, and all you need to do to make that work is pass the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useErrorBoundary\"), \" flag to your query (or provide it via a default config):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=useErrorBoundary\"\n  }, \"function TodoList() {\\n  // \\u2705 will propagate all fetching errors to the nearest Error Boundary\\n  const todos = useQuery(['todos'], fetchTodos, { useErrorBoundary: true })\\n\\n  if (todos.data) {\\n    return (\\n      <div>\\n        {todos.data.map((todo) => (\\n          <Todo key={todo.id} {...todo} />\\n        ))}\\n      </div>\\n    )\\n  }\\n\\n  return 'Loading...'\\n}\\n\")), mdx(\"p\", null, \"Starting with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/releases/tag/v3.23.0\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"v3.23.0\"), \", you an even customize which errors should go towards an Error Boundary, and which ones you'd rather handle locally by providing a function to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useErrorBoundary\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=granular-error-boundaries\"\n  }, \"useQuery(['todos'], fetchTodos, {\\n  // \\uD83D\\uDE80 only server errors will go to the Error Boundary\\n  useErrorBoundary: (error) => error.response?.status >= 500,\\n})\\n\")), mdx(\"p\", null, \"This also works for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/mutations\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"mutations\"), \", and is quite helpful for when you're doing form submissions. Errors in the 4xx range can be handled locally (e.g. if some backend validation failed), while all 5xx server errors can be propagated to the Error Boundary.\"), mdx(\"h2\", {\n    \"id\": \"showing-error-notifications\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Showing error notifications\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#showing-error-notifications\",\n    \"aria-label\": \"showing error notifications permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"For some use-cases, it might be better to show error toast notifications that pop up somewhere (and disappear automatically) instead of rendering Alert banners on the screen. These are usually opened with an imperative api, like the one offered by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-hot-toast.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"react-hot-toast\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=react-hot-toast\"\n  }, \"import toast from 'react-hot-toast'\\n\\ntoast.error('Something went wrong')\\n\")), mdx(\"p\", null, \"So how can we do this when getting an error from React Query?\"), mdx(\"h3\", {\n    \"id\": \"the-onerror-callback\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"The onError callback\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#the-onerror-callback\",\n    \"aria-label\": \"the onerror callback permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(SpacingBox, {\n    mdxType: \"SpacingBox\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=the-onError-callback\"\n  }, \"const useTodos = () =>\\n  useQuery(['todos'], fetchTodos, {\\n    // \\u26A0\\uFE0F looks good, but is maybe _not_ what you want\\n    onError: (error) =>\\n      toast.error(`Something went wrong: ${error.message}`),\\n  })\\n\")), mdx(\"p\", null, \"At first glance, it looks like the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"onError\"), \" callback is exactly what we need to perform a side effect if a fetch fails, and it will also work - for as long as we only use the custom hook once!\"), mdx(\"p\", null, \"You see, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"onError\"), \" callback on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" is called for every \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Observer\"), \", which means if you call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useTodos\"), \" twice in your application, you will get two error toasts, even though only one network request fails.\"), mdx(\"p\", null, \"Conceptually, you can imagine that the onError callback functions similar to a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \". So if we expand the above example to that syntax, it will become more apparent that this will run for every consumer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=useEffect-error-toast\"\n  }, \"const useTodos = () => {\\n  const todos = useQuery(['todos'], fetchTodos)\\n\\n  // \\uD83D\\uDEA8 effects are executed for every component\\n  // that uses this custom hook individually\\n  React.useEffect(() => {\\n    if (todos.error) {\\n      toast.error(`Something went wrong: ${todos.error.message}`)\\n    }\\n  }, [todos.error])\\n\\n  return todos\\n}\\n\")), mdx(\"p\", null, \"Of course, if you don't add the callback to your custom hook, but to the invocation of the hook, this is totally fine. But what if we don't really want to notify all Observers that our fetch failed, but just notify the user \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"once\"), \" that the underlying fetch failed? For that, React Query has callbacks on a different level:\"), mdx(\"h3\", {\n    \"id\": \"the-global-callbacks\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"The global callbacks\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#the-global-callbacks\",\n    \"aria-label\": \"the global callbacks permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The global callbacks need to be provided when you create the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryCache\"), \", which happens implicitly when you create a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"new QueryClient\"), \", but you can also customize that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=query-cache-callbacks\"\n  }, \"const queryClient = new QueryClient({\\n  queryCache: new QueryCache({\\n    onError: (error) =>\\n      toast.error(`Something went wrong: ${error.message}`),\\n  }),\\n})\\n\")), mdx(\"p\", null, \"This will now only show an error toast once for each query, which exactly what we want \\uD83E\\uDD73. It is also likely the best place to put any sort of error tracking or monitoring that you want to perform, because it's guaranteed to run only once per request and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cannot\"), \" be overwritten like e.g. the defaultOptions.\"), mdx(\"h2\", {\n    \"id\": \"putting-it-all-together\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Putting it all together\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#putting-it-all-together\",\n    \"aria-label\": \"putting it all together permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The three main ways to handle errors in React Query are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"error\"), \" property returned from useQuery\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"onError\"), \" callback (on the query itself or the global QueryCache / MutationCache)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"using Error Boundaries\")), mdx(\"p\", null, \"You can mix and match them however you want, and what I personally like to do is show error toasts for background refetches (to keep the stale UI intact) and handle everything else locally or with Error Boundaries:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=background-error-toasts\"\n  }, \"const queryClient = new QueryClient({\\n  queryCache: new QueryCache({\\n    onError: (error, query) => {\\n      // \\uD83C\\uDF89 only show error toasts if we already have data in the cache\\n      // which indicates a failed background update\\n      if (query.state.data !== undefined) {\\n        toast.error(`Something went wrong: ${error.message}`)\\n      }\\n    },\\n  }),\\n})\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #â€¦","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/81915dee3ffd49bc0840fbb93cb81b71/a6c62/error-handling.jpg"}}}}},"pageContext":{"slug":"/react-query-error-handling","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}