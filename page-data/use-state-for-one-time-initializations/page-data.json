{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/use-state-for-one-time-initializations",
    "result": {"data":{"post":{"slug":"/use-state-for-one-time-initializations","title":"useState for one-time initializations","date":"12.03.2021","tags":[{"name":"React","slug":"react"},{"name":"useState pitfalls","slug":"use-state-pitfalls"},{"name":"useMemo","slug":"use-memo"}],"description":"Why you shouldn't rely on useMemo for guaranteed referential stability but prefer useState instead","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"useState for one-time initializations\",\n  \"description\": \"Why you shouldn't rely on useMemo for guaranteed referential stability but prefer useState instead\",\n  \"date\": \"2021-03-12T00:00:00.000Z\",\n  \"banner\": \"../dont-over-usestate/use-state-pitfalls.png\",\n  \"tags\": [\"React\", \"useState pitfalls\", \"useMemo\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"64.58333333333334%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACFElEQVQ4y41Ty27TUBD1NyC1oU1tX9txHrWdtE6aOK86bZ4NLwWFRUEtgvCoUAktICEQAiEWSCDEApC6QkhsQAJWfAJrfumgmVsCMkF0MdHN3DPnzjkzVkzTxJ9hGAYHncVCHPr8HAwh5Dkuz79w0VoKZVqSC3QN/uA8ils7MBMJZDunEFwew3ZcGLqOf9VNJRSainShhMLmCOlCgN7rj8gPt5l06eSQOzUta2qXSlQuAbXYLLz1Hmp7j1C8eAPdVx9Q33+M8tV9lC7tQjs+OyGLkkY6tCDUBWTbJ1Dcuo7Oy/doPn2L8s5d1O88Qf/gC8rXbiN/bvtoHRKIhlAbP0RqKX/Y0U0Mv/3gXOPBc5gJW977K2zNfz0kw5NeDsGVPWy8+YTOi3fsZXjvGfoHX5nUWW1C6BorOpKH+lwM6WKZiZzaGgafvyMY3eKh+INNqDPHYFqJvyTT/6lTNoSOZG6Z/fLPXkB19z6TB6Mxst3TvJP0cHQoTEg/5IXQNA6STDk9Po9MqQq30YYWm0Ey58Nr9eXiCyFxQmLlWS68YtlJLFZDuKsteM0NlkUrQz5RbrESwnY8ZIoVZFbKnKf7XO/MBOPU1/lBIlYs24a71oUbtuGGLfYsE9QY7FQbcBsdJFJpeM0+F2ZKFaSWC4wlHE2bHqWtYEKWrKpStqoeytZ+26CqMAzB8iaW6DrfE26SF/Jz/AlJI5cbzynO4QAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"use state pitfalls\",\n    \"title\": \"use state pitfalls\",\n    \"src\": \"/blog/static/3618c6401c627a3352a2218e5567bfab/7d769/use-state-pitfalls.png\",\n    \"srcSet\": [\"/blog/static/3618c6401c627a3352a2218e5567bfab/5243c/use-state-pitfalls.png 240w\", \"/blog/static/3618c6401c627a3352a2218e5567bfab/ab158/use-state-pitfalls.png 480w\", \"/blog/static/3618c6401c627a3352a2218e5567bfab/7d769/use-state-pitfalls.png 960w\", \"/blog/static/3618c6401c627a3352a2218e5567bfab/87339/use-state-pitfalls.png 1440w\", \"/blog/static/3618c6401c627a3352a2218e5567bfab/89fe2/use-state-pitfalls.png 1642w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"dont-over-use-state\"\n  }, \"#1: Don't over useState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"putting-props-to-use-state\"\n  }, \"#2: Putting props to useState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"things-to-know-about-use-state\"\n  }, \"#3: Things to know about useState\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#4: useState for one-time initializations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"use-state-vs-use-reducer\"\n  }, \"#5: useState vs. useReducer\"))), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"When we talk about memoization and keeping references stable, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \" is usually the first thing that comes to mind. I'm not in the mood for writing much text today,so I'm just gonna lead with a (real-world) example that happened to me this week:\"), mdx(\"h2\", {\n    \"id\": \"the-example\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"The Example\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-example\",\n    \"aria-label\": \"the example permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Suppose you have a resource that you only want to initialize once per life-time of your app. The recommended pattern is usually to create the instance \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"outside\"), \" of the component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=static-instance\"\n  }, \"// \\u2705 static instance is only created once\\nconst resource = new Resource()\\n\\nconst Component = () => (\\n  <ResourceProvider resource={resource}>\\n    <App />\\n  </ResourceProvider>\\n)\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"const resource\"), \" is created once when the js bundle is evaluated, and then made available to our app via the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ResourceProvider\"), \". So far, so good. This usually works well for resources that you need once per App, like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-redux.js.org/api/provider#example-usage\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"redux stores\"), \".\"), mdx(\"p\", null, \"In our case however, we were mounting the Component (a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://micro-frontends.org/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"micro-frontend\"), \") multiple times, and each one needs their own \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"resource\"), \". All hell breaks loose if two of those share the same resource. So we needed to move it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"into\"), \" the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Component\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=create-in-component\"\n  }, \"const Component = () => {\\n  // \\uD83D\\uDEA8 be aware: new instance is created every render\\n  const resource = new Resource()\\n  return (\\n    <ResourceProvider resource={new Resource()}>\\n      <App />\\n    </ResourceProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"I think it is rather obvious that this is not a good idea. The render function now creates a new Resource on every render! This will coincidentally work if we only render our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Component\"), \" once, but this is nothing you should ever rely on. Re-renders can (and likely will) happen, so be prepared!\"), mdx(\"p\", null, \"The first solution that came to our mind was to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \". After all, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \" is for only re-computing values if dependencies change, and we don't have a dependency here, so this looked wonderful:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=use-memo\"\n  }, \"const Component = () => {\\n  // \\uD83D\\uDEA8 still not truly stable\\n  const resource = React.useMemo(() => new Resource(), [])\\n  return (\\n    <ResourceProvider resource={resource}>\\n      <App />\\n    </ResourceProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Again, this might coincidentally work for some time, but let's have a look at what the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/hooks-reference.html#usememo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"react docs\"), \" have to say about \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \":\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to \\u201Cforget\\u201D some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo \\u2014 and then add it to optimize performance.\")), mdx(\"p\", null, \"Wait, what? If we should write our code in a way that it still works without \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \", we are basically not making our code any better by adding it. We are not really concerned about performance here, we want true referential stability please. What's the best way to achieve this?\"), mdx(\"h3\", {\n    \"id\": \"state-to-the-rescue\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"state to the rescue\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#state-to-the-rescue\",\n    \"aria-label\": \"state to the rescue permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Turns out, it's \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"state\"), \". State is guaranteed to only update if you call the setter. So all we need to do is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" call the setter, and since it's the second part of the returned tuple, we can just \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" destruct it. We can even combine this very well with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"things-to-know-about-use-state#2-the-lazy-initializer\"\n  }, \"lazy initializer\"), \" to make sure the resource constructor is only invoked once:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=use-state\"\n  }, \"const Component = () => {\\n  // \\u2705 truly stable\\n  const [resource] = React.useState(() => new Resource())\\n  return (\\n    <ResourceProvider resource={resource}>\\n      <App />\\n    </ResourceProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"With this trick, we will make sure that our resource is truly only created once per component lifecycle \\uD83D\\uDE80.\"), mdx(\"h3\", {\n    \"id\": \"what-about-refs\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"what about refs?\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#what-about-refs\",\n    \"aria-label\": \"what about refs permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I think you can achieve the same with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/hooks-reference.html#useref\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"useRef\"), \", and according to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://gist.github.com/sebmarkbage/75f0838967cd003cd7f9ab938eb1958f\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"rules of react\"), \", this wouldn't even break purity of the render function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=use-ref\"\n  }, \"const Component = () => {\\n  // \\u2705 also works, but meh\\n  const resource = React.useRef(null)\\n  if (!resource.current) {\\n    resource.current = new Resource()\\n  }\\n  return (\\n    <ResourceProvider resource={resource.current}>\\n      <App />\\n    </ResourceProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Honestly, I don't know why you should do it this way - I think this looks rather convoluted, and TypeScript will also not like it, because \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"resource.current\"), \" can technically be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"null\"), \". I prefer to just \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useState\"), \" for these cases.\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"Leave a comment below \\u2B07\\uFE0F or reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \" if you have any questions\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Don't over useState #2: Putting props to useState #3: Things to know about useState #5: useState vs. useReducer When we talk aboutâ€¦","timeToRead":2,"banner":{"childImageSharp":{"resize":{"src":"/static/3618c6401c627a3352a2218e5567bfab/73f08/use-state-pitfalls.png"}}}}},"pageContext":{"slug":"/use-state-for-one-time-initializations","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}