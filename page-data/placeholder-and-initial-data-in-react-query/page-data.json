{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/placeholder-and-initial-data-in-react-query",
    "result": {"data":{"post":{"slug":"/placeholder-and-initial-data-in-react-query","title":"Placeholder and Initial Data in React Query","date":"09.08.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"Learn about the different possibilities to avoid loading spinners in React Query.","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Placeholder and Initial Data in React Query\",\n  \"description\": \"Learn about the different possibilities to avoid loading spinners in React Query.\",\n  \"date\": \"2021-08-09T00:00:00.000Z\",\n  \"banner\": \"./placeholder-and-initial-data.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"75%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHlrDKkf//EABoQAAIDAQEAAAAAAAAAAAAAAAARAQMTAiH/2gAIAQEAAQUCmlGXiOrnOxKP/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8BR//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAMAAwAAAAAAAAAAAAAAAAABMRAhYf/aAAgBAQAGPwJD5iD1Sn//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQAxIVH/2gAIAQEAAT8h+wjPdFQZhRg6AUchPfAJOi83/9oADAMBAAIAAwAAABDX3//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8QUmlH/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8QZ//EABoQAAIDAQEAAAAAAAAAAAAAAAERACExUUH/2gAIAQEAAT8QRJMyDsf5wPZ5GVsOEYQPgUHGhlnaUMk+wGo8n//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"placeholder and initial data\",\n    \"title\": \"placeholder and initial data\",\n    \"src\": \"/blog/static/4ee595d88b40efaf69dcc173ed492632/bbe0c/placeholder-and-initial-data.jpg\",\n    \"srcSet\": [\"/blog/static/4ee595d88b40efaf69dcc173ed492632/46946/placeholder-and-initial-data.jpg 240w\", \"/blog/static/4ee595d88b40efaf69dcc173ed492632/55489/placeholder-and-initial-data.jpg 480w\", \"/blog/static/4ee595d88b40efaf69dcc173ed492632/bbe0c/placeholder-and-initial-data.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Marco Bianchetti\",\n    url: \"https://unsplash.com/@marcobian\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, \"Today's article is all about improving the user experience when working with React Query. Most of the time, we (and our users) dislike pesky loading spinners. They are a necessity sometimes, but we still want to avoid them if possible.\"), mdx(\"p\", null, \"React Query already gives us the tools to get rid of them in many situations. We get stale data from the cache while background updates are happening, we can \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/prefetching\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"prefetch data\"), \" if we know that we need it later, and we can even \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/paginated-queries#better-paginated-queries-with-keeppreviousdata\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"keep previous data\"), \" when our query keys change to avoid those hard loading states.\"), mdx(\"p\", null, \"Another way is to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"synchronously\"), \" pre-fill the cache with data that we think will potentially be right for our use-case, and for that, React Query offers two different yet similar approaches: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/placeholder-query-data\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Placeholder Data\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/initial-query-data\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Initial Data\"), \".\"), mdx(\"p\", null, \"Let's start with what they both have in common before exploring their differences and the situations where one might be better suited than the other.\"), mdx(\"h2\", {\n    \"id\": \"similarities\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Similarities\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#similarities\",\n    \"aria-label\": \"similarities permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"As already hinted, they both provide a way to pre-fill the cache with data that we have synchronously available. It further means that if either one of these is supplied, our query will not be in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"loading\"), \" state, but will go directly to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"success\"), \" state. Also, they can both be either a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"value\"), \" or a function that returns a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"value\"), \", for those times when computing that value is expensive:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=success-queries\"\n  }, \"function Component() {\\n  // \\u2705 status will be success even if we have not yet fetched data\\n  const { data, status } = useQuery(['number'], fetchNumber, {\\n    placeholderData: 23,\\n  })\\n\\n  // \\u2705 same goes for initialData\\n  const { data, status } = useQuery(['number'], fetchNumber, {\\n    initialData: () => 42,\\n  })\\n}\\n\")), mdx(\"p\", null, \"Lastly, neither has an effect if you already have data in your cache. So what difference does it make if I use one or the other? To understand that, we have to briefly take a look at how (and on which \\\"level\\\") the options in React Query work:\"), mdx(\"h3\", {\n    \"id\": \"on-cache-level\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"On cache level\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#on-cache-level\",\n    \"aria-label\": \"on cache level permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"For each Query Key, there is only one cache entry. This is kinda obvious because part of what makes React Query great is the possibility to share the same data \\\"globally\\\" in our application.\"), mdx(\"p\", null, \"Some options we provide to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" will affect that cache entry, prominent examples are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cacheTime\"), \". Since there is only \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"one\"), \" cache entry, those options specify when that entry is considered stale, or when it can be garbage collected.\"), mdx(\"h3\", {\n    \"id\": \"on-observer-level\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"On observer level\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#on-observer-level\",\n    \"aria-label\": \"on observer level permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"An observer in React Query is, broadly speaking, a subscription created for one cache entry. The observer watches the cache entry for changes and will be informed every time something changes.\"), mdx(\"p\", null, \"The basic way to create an observer is to call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \". Every time we do that, we create an observer, and our component will re-render when data changes. This of course means we can have multiple observers watching the same cache entry.\"), mdx(\"p\", null, \"By the way, you can see how many observers a query has by the number on the left of the Query Key in the React Query Devtools (3 in this example):\"), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"875px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"18.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7UlEQVQY02Ow1LX7z6tk9l9E2fy/MBoWUjL7r2jj9l/dw/e/pmPkfzX7lP/O3t7/JxbI/I8Ls/ivZh7wX9fK67+igdN/WV37/1Katv8ZbHRs/7PLGv0XVDABGwDCEAPN/gsqmv4vqe34v3Ld1v9LVm36v2Ld1v9zFq/+X9HY83/63CX/+6fO/T9tzmIwrmnp++8anPyfQVlH+7+ynu1/eU3T/7wSav95JFQRWFz1v6CM1n9hOW04FpLV+i8oownhy0L4MMwnqf6fQVxW6b+AtMZ/QSnV/9yiCv+5RRQgNBRzCstjYC4sYmBxEYX/ACWugGn4ZT9OAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"observers\",\n    \"title\": \"observers\",\n    \"src\": \"/blog/static/986ddce4accc50a039147674f2ece7c1/9bf66/observers.png\",\n    \"srcSet\": [\"/blog/static/986ddce4accc50a039147674f2ece7c1/5243c/observers.png 240w\", \"/blog/static/986ddce4accc50a039147674f2ece7c1/ab158/observers.png 480w\", \"/blog/static/986ddce4accc50a039147674f2ece7c1/9bf66/observers.png 875w\"],\n    \"sizes\": \"(max-width: 875px) 100vw, 875px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(\"p\", null, \"Some options that work on observer level would be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"select\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"keepPreviousData\"), \". In fact, what's makes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"select\"), \" so great for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./react-query-data-transformations#3-using-the-select-option\"\n  }, \"data transformations\"), \" is the ability to watch the same cache entry, but subscribe to different slices of its data in different components.\"), mdx(\"h2\", {\n    \"id\": \"differences\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Differences\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#differences\",\n    \"aria-label\": \"differences permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"InitialData\"), \" works on cache level, while \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"placeholderData\"), \" works on observer level. This has a couple of implications:\"), mdx(\"h3\", {\n    \"id\": \"persistence\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Persistence\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#persistence\",\n    \"aria-label\": \"persistence permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"First of all, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialData\"), \" is persisted to the cache. It's one way of telling React Query: I have \\\"good\\\" data for my use-case already, data that is as good as if it were fetched from the backend. Because it works on cache level, there can only be one \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialData\"), \", and that data will be put into the cache as soon as the cache entry is created (meaning when the first observer mounts). If you try to mount a second observer with different \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialData\"), \", it won't do anything.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PlaceholderData\"), \" on the other hand is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"never\"), \" persisted to the cache. I like to see it as \\\"fake-it-till-you-make-it\\\" data. It's \\\"not real\\\". React Query gives it to you so that you can show it while the real data is being fetched. Because it works on observer level, you can theoretically even have different \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"placeholderData\"), \" for different components.\"), mdx(\"h3\", {\n    \"id\": \"background-refetches\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Background refetches\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#background-refetches\",\n    \"aria-label\": \"background refetches permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"With \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"placeholderData\"), \", you will always get a background refetch when you mount an observer for the first time. Because the data is \\\"not real\\\", React Query will get the real data for you. While this is happening, you will also get an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"isPlaceholderData\"), \" flag returned from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \". You can use this flag to visually hint to your users that the data they are seeing is in fact just placeholderData. It will transition back to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"false\"), \" as soon as the real data comes in.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"InitialData\"), \" on the other hand, because data is seen as good and valid data that we actually put into our cache, respects \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \". If you have a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \" of zero (which is the default), you will still see a background refetch.\"), mdx(\"p\", null, \"But if you've set a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \" (e.g. 30 seconds) on your query, React Query will see the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialData\"), \" and be like:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Oh, I'm getting fresh and new data here synchronously, thank you very much, now I don't need to go to the backend because this data is good for 30 seconds.\")), mdx(\"p\", {\n    style: {\n      \"paddingLeft\": \"3rem\",\n      \"marginTop\": \"-1rem\"\n    }\n  }, \"\\u2014 React Query when it sees \", mdx(\"i\", null, \"initialData\"), \" and \", mdx(\"i\", null, \"staleTime\")), mdx(\"p\", null, \"If that's not what you want, you can provide \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialDataUpdatedAt\"), \" to your query. This will tell React Query when this initialData has been created, and background refetches will be triggered, taking this into account as well. This is extremely helpful when using initialData from an existing cache entry by using the available \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dataUpdatedAt\"), \" timestamp:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx:title=initialDataUpdatedAt\"\n  }, \"const useTodo = (id) => {\\n  const queryClient = useQueryClient()\\n\\n  return useQuery(['todo', id], () => fetchTodo(id), {\\n    staleTime: 30 * 1000,\\n    initialData: () =>\\n      queryClient\\n        .getQueryData(['todo', 'list'])\\n        ?.find((todo) => todo.id === id),\\n    initialDataUpdatedAt: () =>\\n      // \\u2705 will refetch in the background if our list query data is older\\n      // than the provided staleTime (30 seconds)\\n      queryClient.getQueryState(['todo', 'list'])?.dataUpdatedAt,\\n  })\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"error-transitions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Error transitions\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#error-transitions\",\n    \"aria-label\": \"error transitions permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Suppose you provide \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialData\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"placeholderData\"), \", and a background refetch is triggered, which then fails. What do you think will happen in each situation? I've hidden the answers so that you can try to come up with them for yourselves if you want before expanding them.\"), mdx(\"p\", null, mdx(\"details\", null, mdx(\"summary\", null, \"InitialData\"), \"Since \", mdx(\"i\", null, \"initialData\"), \" is persisted in the cache, the refetch error is treated like any other background error. Our query will be in \", mdx(\"i\", null, \"error\"), \" state, but your \", mdx(\"i\", null, \"data\"), \" will still be there.\")), mdx(\"p\", null, mdx(\"details\", null, mdx(\"summary\", null, \"PlaceholderData\"), \"Since \", mdx(\"i\", null, \"placeholderData\"), \" is \\\"fake-it-till-you-make-it\\\" data, and we didn't make it, we won't see that data anymore. Our query will be in \", mdx(\"i\", null, \"error\"), \" state, and our \", mdx(\"i\", null, \"data\"), \" will be \", mdx(\"i\", null, \"undefined\"), \".\")), mdx(\"h2\", {\n    \"id\": \"when-to-use-what\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"When to use what\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#when-to-use-what\",\n    \"aria-label\": \"when to use what permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"As always, that is totally up to you. I personally like to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"initialData\"), \" when pre-filling a query from another query, and I use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"placeholderData\"), \" for everything else.\"), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #…","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/4ee595d88b40efaf69dcc173ed492632/a6c62/placeholder-and-initial-data.jpg"}}}}},"pageContext":{"slug":"/placeholder-and-initial-data-in-react-query","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}