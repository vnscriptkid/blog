{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/react-query-as-a-state-manager",
    "result": {"data":{"post":{"slug":"/react-query-as-a-state-manager","title":"React Query as a State Manager","date":"20.08.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"Everything you need to know to make React Query your single source of truth state manager for your async state","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Query as a State Manager\",\n  \"description\": \"Everything you need to know to make React Query your single source of truth state manager for your async state\",\n  \"date\": \"2021-08-20T00:00:00.000Z\",\n  \"banner\": \"./state-management.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBv/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAF7M/SUERX/xAAcEAABAwUAAAAAAAAAAAAAAAABAAIDERMhIjH/2gAIAQEAAQUCZPQXtTJkFRuTu//EABYRAAMAAAAAAAAAAAAAAAAAAAECEP/aAAgBAwEBPwEPP//EABYRAQEBAAAAAAAAAAAAAAAAAAECEP/aAAgBAgEBPwFkz//EABgQAAMBAQAAAAAAAAAAAAAAAAABECEx/9oACAEBAAY/AjTrjn//xAAaEAEAAgMBAAAAAAAAAAAAAAABABEhQYHh/9oACAEBAAE/IcKAdiVUL0z2UXBHuaaT/9oADAMBAAIAAwAAABBQ3//EABcRAQEBAQAAAAAAAAAAAAAAAAEAITH/2gAIAQMBAT8QRdlR7f/EABYRAQEBAAAAAAAAAAAAAAAAAAEAQf/aAAgBAgEBPxDFAX//xAAbEAEAAwEAAwAAAAAAAAAAAAABABEhMUFRYf/aAAgBAQABPxAAoB7zDGMHjCgLbOwYfK2W3K54Z//Z')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"state management\",\n    \"title\": \"state management\",\n    \"src\": \"/blog/static/5a19c221b205ccdd8189d6d6ff7fd9cc/bbe0c/state-management.jpg\",\n    \"srcSet\": [\"/blog/static/5a19c221b205ccdd8189d6d6ff7fd9cc/46946/state-management.jpg 240w\", \"/blog/static/5a19c221b205ccdd8189d6d6ff7fd9cc/55489/state-management.jpg 480w\", \"/blog/static/5a19c221b205ccdd8189d6d6ff7fd9cc/bbe0c/state-management.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"OpticalNomad\",\n    url: \"https://unsplash.com/@opticalnomad\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-render-optimizations\"\n  }, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(\"hr\", null), mdx(\"p\", null, \"React Query is loved by many for drastically simplifying data fetching in React applications. So it might come as a bit of a surprise if I tell you that React Query is in fact \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"NOT\"), \" a data fetching library.\"), mdx(\"p\", null, \"It doesn't fetch any data for you, and only a very small set of features are directly tied to the network (like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/onlineManager\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"the OnlineManager\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetchOnReconnect\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/mutations#retry\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"retrying offline mutation\"), \"). This also becomes apparent when you write your first \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \", and you have to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"something\"), \" to actually get the data, like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"fetch\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://axios-http.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"axios\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/sindresorhus/ky\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"ky\"), \" or even \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/prisma-labs/graphql-request\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"graphql-request\"), \".\"), mdx(\"p\", null, \"So if React Query is no data fetching library, what is it?\"), mdx(\"h2\", {\n    \"id\": \"an-async-state-manager\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"An Async State Manager\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#an-async-state-manager\",\n    \"aria-label\": \"an async state manager permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"React Query is an async state manager. It can manage any form of asynchronous state - it is happy as long as it gets a Promise. Yes, most of the time, we produce Promises via data fetching, so that's where it shines. But it does more than just handling loading and error states for you. It is a proper, real, \\\"global state manager\\\". The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryKey\"), \" uniquely identifies your query, so as long you call the query with the same key in two different places, they will get the same data. This can be best abstracted with a custom hook so that we don't have to access the actual data fetching function twice:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=async-state-manager\"\n  }, \"export const useTodos = () => useQuery(['todos'], fetchTodos)\\n\\nfunction ComponentOne() {\\n  const { data } = useTodos()\\n}\\n\\nfunction ComponentTwo() {\\n  // \\u2705 will get exactly the same data as ComponentOne\\n  const { data } = useTodos()\\n}\\n\\nconst queryClient = new QueryClient()\\n\\nfunction App() {\\n  return (\\n    <QueryClientProvider client={queryClient}>\\n      <ComponentOne />\\n      <ComponentTwo />\\n    </QueryClientProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Those components can be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"anywhere\"), \" in your component tree. As long as they are under the same \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"QueryClientProvider\"), \", they will get the same data.\\nReact Query will also \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"deduplicate\"), \" requests that would happen at the same time, so in the above scenario, even though two components request the same data, there will be only one network request.\"), mdx(\"h2\", {\n    \"id\": \"a-data-synchronization-tool\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"A data synchronization tool\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#a-data-synchronization-tool\",\n    \"aria-label\": \"a data synchronization tool permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Because React Query manages async state (or, in terms of data fetching: server state), it assumes that the frontend application doesn't \\\"own\\\" the data. And that's totally right. If we display data on the screen that we fetch from an API, we only display a \\\"snapshot\\\" of that data - the version of how it looked when we retrieved it. So the question we have to ask ourselves is:\"), mdx(\"p\", null, \"Is that data still accurate after we fetch it?\"), mdx(\"p\", null, \"The answer depends totally on our problem domain. If we fetch a Twitter post with all its likes and comments, it is likely outdated (stale) pretty fast. If we fetch exchange rates that update on a daily basis, well, our data is going to be quite accurate for some time even without refetching.\"), mdx(\"p\", null, \"React Query provides the means to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"synchronize\"), \" our view with the actual data owner - the backend. And by doing so, it errs on the side of updating often rather than not updating often enough.\"), mdx(\"h3\", {\n    \"id\": \"before-react-query\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Before React Query\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#before-react-query\",\n    \"aria-label\": \"before react query permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Two approaches to data fetching were pretty common before libraries like React Query came to the rescue:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"fetch once, distribute globally, rarely update\", mdx(\"br\", null), \"\\nThis is pretty much what I myself have been doing with redux a lot. Somewhere, I dispatch an action that initiates the data fetching, usually on mount of the application. After we get the data, we put it in a global state manager so that we can access it everywhere in our application. After all, many components need access to our Todo list.\\nDo we refetch that data? No, we have \\\"downloaded\\\" it, so we have it already, why should we? Maybe if we fire a POST request to the backend, it will be kind enough to give us the \\\"latest\\\" state back. If you want something more accurate, you can always reload your browser window...\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"fetch on every mount, keep it local\", mdx(\"br\", null), \"\\nSometimes, we might also think that putting data in global state is \\\"too much\\\". We only need it in this Modal Dialog, so why not fetch it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"just in time\"), \" when the Dialog opens. You know the drill: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \", empty dependency array (throw an eslint-disable at it if it screams), \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setLoading(true)\"), \" and so on ... Of course, we now show a loading spinner every time the Dialog opens until we have the data. What else can we do, the local state is gone...\"))), mdx(\"hr\", null), mdx(\"p\", null, \"Both of these approaches are pretty sub-optimal. The first one doesn't update our local cache often enough, while the second one potentially re-fetches too often, and also has a questionable ux because data is not there when we fetch for the second time.\"), mdx(\"p\", null, \"So how does React Query approach these problems?\"), mdx(\"h3\", {\n    \"id\": \"stale-while-revalidate\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Stale While Revalidate\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#stale-while-revalidate\",\n    \"aria-label\": \"stale while revalidate permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"You might have heard this before, it's the caching mechanism that React Query uses. It's nothing new - you can read about the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://datatracker.ietf.org/doc/html/rfc5861\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"HTTP Cache-Control Extensions for Stale Content here\"), \". In summary, it means React Query will cache data for you and give it to you when you need it, even if that data might not be up-to-date (stale) anymore. The principle is that stale data is better than no data, because no data usually means a loading spinner, and this will be perceived as \\\"slow\\\" by users. At the same time, it will try to perform a background refetch to revalidate that data.\"), mdx(\"h3\", {\n    \"id\": \"smart-refetches\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Smart refetches\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#smart-refetches\",\n    \"aria-label\": \"smart refetches permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Cache invalidation is pretty hard, so when do you decide it's time to ask the backend again for new data? Surely we can't just do this every time a component that calls \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" re-renders. That would be insanely expensive, even by modern standards.\"), mdx(\"p\", null, \"So React Query is being smart and chooses strategic points for triggering a refetch. Points that seem to be a good indicator for saying: \\\"Yep, now would be a good time to go get some data\\\". These are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetchOnMount\"), mdx(\"br\", null), \"\\nWhenever a new component that calls \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" mounts, React Query will do a\\nrevalidation.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetchOnWindowFocus\"), mdx(\"br\", null), \"\\nWhenever you focus the browser tab, there will be a refetch. This is my favourite point in time to do a revalidation, but it's often misunderstood. During development, we switch browser tabs very often, so we might perceive this as \\\"too much\\\". In production however, it most likely indicates that a user who left our app open in a tab now comes back from checking mails or reading twitter. Showing them the latest updates makes perfect sense in this situation.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetchOnReconnect\"), mdx(\"br\", null), \"\\nIf you lose your network connection and regain it, it's also a good indicator to revalidate what you see on the screen.\"))), mdx(\"p\", null, \"Finally, if you, as the developer of your app, know a good point in time, you can invoke a manual invalidation via \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryClient.invalidateQueries\"), \". This comes in very handy after you perform a mutation.\"), mdx(\"h3\", {\n    \"id\": \"letting-react-query-do-its-magic\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Letting React Query do its magic\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#letting-react-query-do-its-magic\",\n    \"aria-label\": \"letting react query do its magic permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I love \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/important-defaults\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"these defaults\"), \", but as I said before, they are geared towards keeping things up-to-date, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" to minimize the amount of network requests. This is mainly because \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \" defaults to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"zero\"), \", which means that every time you e.g. mount a new component instance, you will get a background refetch. If you do this a lot, especially with mounts in short succession that are not in the same render cycle, you might see \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"a lot\"), \" of fetches in the network tab. That's because React Query can't deduplicate in such situations:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=mounts-in-short-succession\"\n  }, \"function ComponentOne() {\\n  const { data } = useTodos()\\n\\n  if (data) {\\n    // \\u26A0\\uFE0F mounts conditionally, only after we already have data\\n    return <ComponentTwo />\\n  }\\n  return <Loading />\\n}\\n\\nfunction ComponentTwo() {\\n  // \\u26A0\\uFE0F will thus trigger a second network request\\n  const { data } = useTodos()\\n}\\n\\nconst queryClient = new QueryClient()\\n\\nfunction App() {\\n  return (\\n    <QueryClientProvider client={queryClient}>\\n      <ComponentOne />\\n    </QueryClientProvider>\\n  )\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"What's going on here, I just fetched my data 2 seconds ago, why is there another network request happening? This is insane!\")), mdx(\"p\", {\n    style: {\n      \"paddingLeft\": \"3rem\",\n      \"marginTop\": \"-1rem\"\n    }\n  }, \"\\u2014 Legit reaction when using React Query for the first time\"), mdx(\"p\", null, \"At that point, it might seem like a good idea to either pass \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" down via props, or to put it in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"React Context\"), \" to avoid prop drilling, or to just turn off the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetchOnMount\"), \" / \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"refetchOnWindowFocus\"), \" flags because all of this fetching is just too much!\"), mdx(\"p\", null, \"Generally, there is nothing wrong with passing data as props. It's the most explicit thing you can do, and would work well in the above example. But what if we tweak the example a bit towards a more real-life situation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=lazy-second-component\"\n  }, \"function ComponentOne() {\\n  const { data } = useTodos()\\n  const [showMore, toggleShowMore] = React.useReducer(\\n    (value) => !value,\\n    false\\n  )\\n\\n  // yes, I leave out error handling, this is \\\"just\\\" an example\\n  if (!data) {\\n    return <Loading />\\n  }\\n\\n  return (\\n    <div>\\n      Todo count: {data.length}\\n      <button onClick={toggleShowMore}>Show More</button>\\n      // \\u2705 show ComponentTwo after the button has been clicked\\n      {showMore ? <ComponentTwo /> : null}\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"In this example, our second component (which also depends on the todo data) will only mount after the user clicks a button. Now imagine our user clicks on that button after some minutes. Wouldn't a background refetch be nice in that situation, so that we can see the up-to-date values of our todo list?\"), mdx(\"p\", null, \"This wouldn't be possible if you chose any of the aforementioned approaches that basically bypass what React Query wants to do.\"), mdx(\"p\", null, \"So how can we have our cake and eat it, too?\"), mdx(\"h3\", {\n    \"id\": \"customize-staletime\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Customize \", mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"staleTime\"), mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#customize-staletime\",\n    \"aria-label\": \"customize staletime permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Maybe you've already guessed the direction in which I want to go: The solution would be to set \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \" to a value you are comfortable with for your specific use-case. The key thing to know is:\"), mdx(Highlight, {\n    mdxType: \"Highlight\"\n  }, \"As long as data is fresh, it will always come from the cache only. You will not see a network request for fresh data, no matter how often you want to retrieve it.\"), mdx(\"p\", null, \"There is also no \\\"correct\\\" value for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \". In many situations, the defaults work really well. Personally, I like to set it to a minimum of 20 seconds to deduplicate requests in that time frame, but it's totally up to you.\"), mdx(\"h4\", {\n    \"id\": \"bonus-using-setquerydefaults\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Bonus: using setQueryDefaults\", mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#bonus-using-setquerydefaults\",\n    \"aria-label\": \"bonus using setquerydefaults permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Since v3, React Query supports a great way of setting default values per Query Key via \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"QueryClient.setQueryDefaults\"), \". So if you follow the patterns I've outlined in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), \", you can set defaults for any granularity you want, because passing Query Keys to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"setQueryDefaults\"), \" follows the standard partial matching that e.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://react-query.tanstack.com/guides/filters#query-filters\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Query Filters\"), \" also have:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=setQueryDefaults\"\n  }, \"const queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      // \\u2705 globally default to 20 seconds\\n      staleTime: 1000 * 20,\\n    },\\n  },\\n})\\n\\n// \\uD83D\\uDE80 everything todo-related will have a 1 minute staleTime\\nqueryClient.setQueryDefaults(todoKeys.all, { staleTime: 1000 * 60 })\\n\")), mdx(\"h2\", {\n    \"id\": \"a-note-on-separation-of-concerns\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"A note on separation of concerns\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#a-note-on-separation-of-concerns\",\n    \"aria-label\": \"a note on separation of concerns permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"It is a seemingly legit concern that adding hooks like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" to components of all layers in your app mixes responsibilities of what a component should do. Back in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"old days\"), \", the \\\"smart-vs-dumb\\\", \\\"container-vs-presentational\\\" component pattern was ubiquitous. It promised clear separation, decoupling, reusability and ease of testability because presentational components would just \\\"get props\\\". It also led to lots of prop drilling, boilerplate, patterns that were hard to statically type (\\uD83D\\uDC4B higher-order-components) and arbitrary component splits.\"), mdx(\"p\", null, \"That changed a lot when hooks came around. You can now \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useContext\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"useSelector\"), \" (if you're using redux) everywhere, and thus inject dependencies into your component. You can argue that doing so makes your component more coupled. You can also say that it's now more independent because you can move it around freely in your app, and it will just work on its own.\"), mdx(\"p\", null, \"I can totally recommend watching \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=xiKMbmDv-Vw\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Hooks, HOCS, and Tradeoffs (\\u26A1\\uFE0F) / React Boston 2019\"), \" by redux maintainer \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/acemarke\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Mark Erikson\"), \".\"), mdx(\"p\", null, \"In summary, it's all tradeoffs. There is no free lunch. What might work in one situation might not work in others. Should a reusable \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Button\"), \" component do data fetching? Probably not. Does it make sense to split your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Dashboard\"), \" into a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DashboardView\"), \" and a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DashboardContainer\"), \" that passes data down? Also, probably not. So it's on us to know the tradeoffs and apply the right tool for the right job.\"), mdx(\"h2\", {\n    \"id\": \"takeaways\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Takeaways\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#takeaways\",\n    \"aria-label\": \"takeaways permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"React Query is great at managing async state globally in your app, if you let it. Only turn off the refetch flags if you know that make sense for your use-case, and resist the urge to sync server data to a different state manager. Usually, customizing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"staleTime\"), \" is all you need to get a great ux while also being in control of how often background updates happen.\"), mdx(\"hr\", null), mdx(\"p\", null, \"That's it for today. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #3: React Query Render Optimizations #4: Status Checks in React Query #…","timeToRead":7,"banner":{"childImageSharp":{"resize":{"src":"/static/5a19c221b205ccdd8189d6d6ff7fd9cc/a6c62/state-management.jpg"}}}}},"pageContext":{"slug":"/react-query-as-a-state-manager","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}