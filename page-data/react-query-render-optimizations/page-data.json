{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/react-query-render-optimizations",
    "result": {"data":{"post":{"slug":"/react-query-render-optimizations","title":"React Query Render Optimizations","date":"20.03.2021","tags":[{"name":"react","slug":"react"},{"name":"react-query","slug":"react-query"},{"name":"JavaScript","slug":"java-script"},{"name":"TypeScript","slug":"type-script"}],"description":"An advanced guide to minimize component re-renderings when using React Query","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Query Render Optimizations\",\n  \"description\": \"An advanced guide to minimize component re-renderings when using React Query\",\n  \"date\": \"2021-03-20T00:00:00.000Z\",\n  \"banner\": \"./optimizations.jpeg\",\n  \"tags\": [\"react\", \"react-query\", \"JavaScript\", \"TypeScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"640px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"56.25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQT/xAAWAQEBAQAAAAAAAAAAAAAAAAACAAH/2gAMAwEAAhADEAAAAUa24onSS//EABoQAAICAwAAAAAAAAAAAAAAAAABERICECH/2gAIAQEAAQUC4XSVsWQtQf/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/AYf/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEv/aAAgBAgEBPwG1P//EABsQAAIBBQAAAAAAAAAAAAAAAAARMQEQInGR/9oACAEBAAY/Am9mPSGRap//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMVFxkaH/2gAIAQEAAT8hRpXf1AcRdZUdzsqGDDyDWq8gL23zP//aAAwDAQACAAMAAAAQOA//xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8QUkR//8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oACAECAQE/ENpb/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBUWFxkf/aAAgBAQABPxBmb2Nu/VYuDomg1TwXGBu1ykMU+KWRA9CIbZs5dE//2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"optimizations\",\n    \"title\": \"optimizations\",\n    \"src\": \"/blog/static/0ac0fd0336e25f620a83f91956333882/bbe0c/optimizations.jpg\",\n    \"srcSet\": [\"/blog/static/0ac0fd0336e25f620a83f91956333882/46946/optimizations.jpg 240w\", \"/blog/static/0ac0fd0336e25f620a83f91956333882/55489/optimizations.jpg 480w\", \"/blog/static/0ac0fd0336e25f620a83f91956333882/bbe0c/optimizations.jpg 640w\"],\n    \"sizes\": \"(max-width: 640px) 100vw, 640px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \"), mdx(Attribution, {\n    name: \"Lukasz Szmigiel\",\n    url: \"https://unsplash.com/@szmigieldesign\",\n    mdxType: \"Attribution\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"practical-react-query\"\n  }, \"#1: Practical React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"b\", null, \"#3: React Query Render Optimizations\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"status-checks-in-react-query\"\n  }, \"#4: Status Checks in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"testing-react-query\"\n  }, \"#5: Testing React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-and-type-script\"\n  }, \"#6: React Query and TypeScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"using-web-sockets-with-react-query\"\n  }, \"#7: Using WebSockets with React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"effective-react-query-keys\"\n  }, \"#8: Effective React Query Keys\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"leveraging-the-query-function-context\"\n  }, \"#8a: Leveraging the Query Function Context\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"placeholder-and-initial-data-in-react-query\"\n  }, \"#9: Placeholder and Initial Data in React Query\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-as-a-state-manager\"\n  }, \"#10: React Query as a State Manager\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"react-query-error-handling\"\n  }, \"#11: React Query Error Handling\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"mastering-mutations-in-react-query\"\n  }, \"#12: Mastering Mutations in React Query\"))), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Disclaimer\"), \": Render optimizations are an advanced concept for any app. React Query already comes with very good optimizations and defaults out of the box, and most of the time, no further optimizations are needed. \\\"Unneeded re-renders\\\" is a topic that many people tend to put a lot of focus on, which is why I've decided to cover it. But I wanted to point out once again, that usually, for most apps, render optimizations probably don't matter as much as you'd think. Re-renders are a good thing. They make sure your app is up-to-date. I'd take an \\\"unnecessary re-render\\\" over a \\\"missing render-that-should-have-been-there\\\" all day every day. For more on this topic, please read:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"Fix the slow render before you fix the re-render\"), \" by Kent C. Dodds\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"this article by @ryanflorence about premature optimizations\"))), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"I've already written quite a bit about render optimizations when describing the select option in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"react-query-data-transformations\"\n  }, \"#2: React Query Data Transformations\"), \". However, \\\"Why does React Query re-render my component two times even though nothing changed in my data\\\" is the question I probably needed to answer the most (apart from maybe: \\\"Where can I find the v2 docs\\\" \\uD83D\\uDE05). So let me try to explain it in-depth.\"), mdx(\"h2\", {\n    \"id\": \"isfetching-transition\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"isFetching transition\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#isfetching-transition\",\n    \"aria-label\": \"isfetching transition permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I haven't been entirely honest in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"react-query-data-transformations#3-using-the-select-option\"\n  }, \"last example\"), \" when I said that this component will only re-render if the length of todos change:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=count-component\"\n  }, \"export const useTodosQuery = (select) =>\\n  useQuery(['todos'], fetchTodos, { select })\\nexport const useTodosCount = () => useTodosQuery((data) => data.length)\\n\\nfunction TodosCount() {\\n  const todosCount = useTodosCount()\\n\\n  return <div>{todosCount.data}</div>\\n}\\n\")), mdx(\"p\", null, \"Every time you make a background refetch, this component will re-render twice with the following query info:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{ status: 'success', data: 2, isFetching: true }\\n{ status: 'success', data: 2, isFetching: false }\\n\")), mdx(\"p\", null, \"That is because React Query exposes a lot of meta information for each query, and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"isFetching\"), \" is one of them. This flag will always be true when a request is in-flight. This is quite useful if you want to display a background loading indicator. But it's also kinda unnecessary if you don't do that.\"), mdx(\"h3\", {\n    \"id\": \"notifyonchangeprops\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"notifyOnChangeProps\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#notifyonchangeprops\",\n    \"aria-label\": \"notifyonchangeprops permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"For this use-case, React Query has the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"notifyOnChangeProps\"), \" option. It can be set on a per-observer level to tell React Query: Please only inform this observer about changes if one of these props change. By setting this option to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"['data']\"), \", we will find the optimized version we seek:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=optimized-with-notifyOnChangeProps\"\n  }, \"export const useTodosQuery = (select, notifyOnChangeProps) =>\\n  useQuery(['todos'], fetchTodos, { select, notifyOnChangeProps })\\nexport const useTodosCount = () =>\\n  useTodosQuery((data) => data.length, ['data'])\\n\")), mdx(\"p\", null, \"You can see this in action in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/blob/9023b0d1f01567161a8c13da5d8d551a324d6c23/examples/optimistic-updates-typescript/pages/index.tsx#L35-L48\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"optimistic-updates-typescript\"), \" example in the docs.\"), mdx(\"h3\", {\n    \"id\": \"staying-in-sync\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Staying in sync\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#staying-in-sync\",\n    \"aria-label\": \"staying in sync permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"While the above code works well, it can get out of sync quite easily. What if we want to react to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"error\"), \", too? Or we start to use the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"isLoading\"), \" flag? We have to keep the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"notifyOnChangeProps\"), \" list in sync with whichever fields we are actually using in our components. If we forget to do that, and we only observe the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" property, but get an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"error\"), \" that we also display, our component will not re-render and is thus outdated. This is especially troublesome if we hard-code this in our custom hook, because the hook does not know what the component will actually use:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=outdated-component\"\n  }, \"export const useTodosCount = () =>\\n  useTodosQuery((data) => data.length, ['data'])\\n\\nfunction TodosCount() {\\n  // \\uD83D\\uDEA8 we are using error, but we are not getting notified if error changes!\\n  const { error, data } = useTodosCount()\\n\\n  return (\\n    <div>\\n      {error ? error : null}\\n      {data ? data : null}\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"As I have hinted in the disclaimer in the beginning, I think this is way worse than the occasional unneeded re-render. Of course, we can pass the option to the custom hook, but this still feels quite manual and boilerplate-y. Is there a way to do this automatically? Turns out, there is:\"), mdx(\"h3\", {\n    \"id\": \"tracked-queries\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Tracked Queries\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#tracked-queries\",\n    \"aria-label\": \"tracked queries permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"I'm quite proud of this feature, given that it was my first major contribution to the library. If you set \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"notifyOnChangeProps\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'tracked'\"), \", React Query will keep track of the fields you are using during render, and will use this to compute the list. This will optimize exactly the same way as specifying the list manually, except that you don't have to think about it. You can also turn this on globally for all your queries:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx:title=tracked-queries\"\n  }, \"const queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      notifyOnChangeProps: 'tracked',\\n    },\\n  },\\n})\\nfunction App() {\\n  return (\\n    <QueryClientProvider client={queryClient}>\\n      <Example />\\n    </QueryClientProvider>\\n  )\\n}\\n\")), mdx(\"p\", null, \"With this, you never have to think about re-renders again. Of course, tracking the usages has a bit of an overhead as well, so make sure you use this wisely. There are also some limitations to tracked queries, which is why this is an opt-in feature:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If you use \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/tc39/proposal-object-rest-spread/blob/6ee4ce3cdda246746fc46fb149bb8b43c28e704d/Rest.md\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"object rest destructuring\"), \", you are effectively observing all fields. Normal destructuring is fine, just don't do this:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=problematic-rest-destructuring\"\n  }, \"// \\uD83D\\uDEA8 will track all fields\\nconst { isLoading, ...queryInfo } = useQuery(...)\\n\\n// \\u2705 this is totally fine\\nconst { isLoading, data } = useQuery(...)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tracked queries only work \\\"during render\\\". If you only access fields during effects, they will not be tracked. This is quite the edge case though because of dependency arrays:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=tracking-effects\"\n  }, \"const queryInfo = useQuery(...)\\n\\n// \\uD83D\\uDEA8 will not corectly track data\\nReact.useEffect(() => {\\n    console.log(queryInfo.data)\\n})\\n\\n// \\u2705 fine because the dependency array is accessed during render\\nReact.useEffect(() => {\\n    console.log(queryInfo.data)\\n}, [queryInfo.data])\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tracked queries don't reset on each render, so if you track a field once, you'll track it for the lifetime of the observer:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=no-reset\"\n  }, \"const queryInfo = useQuery(...)\\n\\nif (someCondition()) {\\n    // \\uD83D\\uDFE1 we will track the data field if someCondition was true in any previous render cycle\\n    return <div>{queryInfo.data}</div>\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"structural-sharing\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Structural sharing\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#structural-sharing\",\n    \"aria-label\": \"structural sharing permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentcolor\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"A different, but no less important render optimization that React Query has turned on out of the box is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"structural sharing\"), \". This feature makes sure that we keep referential identity of our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"data\"), \" on every level. As an example, suppose you have the following data structure:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"id\\\": 1, \\\"name\\\": \\\"Learn React\\\", \\\"status\\\": \\\"active\\\" },\\n  { \\\"id\\\": 2, \\\"name\\\": \\\"Learn React Query\\\", \\\"status\\\": \\\"todo\\\" }\\n]\\n\")), mdx(\"p\", null, \"Now suppose we transition our first todo into the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"done\"), \" state, and we make a background refetch. We'll get a completely new json from our backend:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-diff\"\n  }, \"[\\n-  { \\\"id\\\": 1, \\\"name\\\": \\\"Learn React\\\", \\\"status\\\": \\\"active\\\" },\\n+  { \\\"id\\\": 1, \\\"name\\\": \\\"Learn React\\\", \\\"status\\\": \\\"done\\\" },\\n  { \\\"id\\\": 2, \\\"name\\\": \\\"Learn React Query\\\", \\\"status\\\": \\\"todo\\\" }\\n]\\n\")), mdx(\"p\", null, \"Now React Query will attempt to compare the old state and the new and keep as much of the previous state as possible. In our example, the todos array will be new, because we updated a todo. The object with id 1 will also be new, but the object for id 2 will be the same reference as the one in the previous state - React Query will just copy it over to the new result because nothing has changed in it.\"), mdx(\"p\", null, \"This comes in very handy when using selectors for partial subscriptions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=optimized-selectors\"\n  }, \"// \\u2705 will only re-render if _something_ within todo with id:2 changes\\n// thanks to structural sharing\\nconst { data } = useTodo(2)\\n\")), mdx(\"p\", null, \"As I've hinted before, for selectors, structural sharing will be done twice: Once on the result returned from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"queryFn\"), \" to determine if anything changed at all, and then once more on the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"result\"), \" of the selector function. In some instances, especially when having very large datasets, structural sharing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"can\"), \" be a bottleneck. It also only works on json-serializable data. If you don't need this optimization, you can turn it off by setting \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"structuralSharing: false\"), \" on any query.\"), mdx(\"p\", null, \"Have a look at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tannerlinsley/react-query/blob/80cecef22c3e088d6cd9f8fbc5cd9e2c0aab962f/src/core/tests/utils.test.tsx#L97-L304\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"replaceEqualDeep tests\"), \" if you want to learn more about what happens under the hood.\"), mdx(Divider, {\n    mdxType: \"Divider\"\n  }), mdx(\"p\", null, \"Phew, this was quite a handful. Feel free to reach out to me on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tkdodo\",\n    \"target\": \"_blank\",\n    \"rel\": \"noreferrer noopener\"\n  }, \"twitter\"), \"\\nif you have any questions, or just leave a comment below \\u2B07\\uFE0F. I'm always happy to help!\"), mdx(Comments, {\n    withSeparator: false,\n    mdxType: \"Comments\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"#1: Practical React Query #2: React Query Data Transformations #4: Status Checks in React Query #5: Testing React Query #6: React Query andâ€¦","timeToRead":4,"banner":{"childImageSharp":{"resize":{"src":"/static/0ac0fd0336e25f620a83f91956333882/a6c62/optimizations.jpg"}}}}},"pageContext":{"slug":"/react-query-render-optimizations","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}